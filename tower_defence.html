<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>2Då¼€æ”¾åœºåœ°å¡”é˜²æ¸¸æˆ</title>
    <style>
        body {
            margin: 0;
            padding: 20px;
            background: #2c3e50;
            font-family: Arial, sans-serif;
            color: white;
        }
        
        .game-container {
            display: flex;
            gap: 20px;
            height: calc(100vh - 120px);
            min-height: 600px;
        }
        
        #gameCanvas {
            border: 2px solid #34495e;
            background: #27ae60;
            cursor: crosshair;
            flex-shrink: 0;
        }
        
        .ui-panel {
            background: #34495e;
            padding: 15px;
            border-radius: 8px;
            width: 220px;
            height: 100%;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
            flex-shrink: 0;
        }
        
        .stats-section {
            margin-bottom: 15px;
        }
        
        .stat {
            margin: 5px 0;
            font-size: 14px;
            display: flex;
            justify-content: space-between;
        }
        
        .towers-section {
            margin-bottom: 15px;
        }
        
        .section-title {
            font-size: 14px;
            font-weight: bold;
            margin-bottom: 8px;
            color: #ecf0f1;
        }
        
        .tower-btn {
            display: block;
            width: 100%;
            margin: 5px 0;
            padding: 8px;
            background: #3498db;
            border: none;
            border-radius: 4px;
            color: white;
            cursor: pointer;
            font-size: 12px;
            transition: background 0.2s;
        }
        
        .tower-btn:hover {
            background: #2980b9;
        }
        
        .tower-btn.selected {
            background: #e74c3c;
        }
        
        .wave-btn {
            background: #e67e22;
            margin-top: 10px;
            padding: 10px;
            font-size: 13px;
        }
        
        .wave-btn:hover {
            background: #d35400;
        }
        
        .notifications-area {
            margin-top: auto;
            min-height: 80px;
            background: rgba(0,0,0,0.2);
            border-radius: 4px;
            padding: 8px;
        }
        
        .notifications-title {
            font-size: 12px;
            font-weight: bold;
            margin-bottom: 5px;
            color: #bdc3c7;
        }
        
        .notification {
            font-size: 11px;
            margin: 3px 0;
            padding: 2px 4px;
            border-radius: 2px;
            background: rgba(255,255,255,0.1);
        }
        
        .game-over {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0,0,0,0.8);
            padding: 30px;
            border-radius: 10px;
            text-align: center;
            display: none;
        }
    </style>
</head>
<body>
    <h1>2Då¼€æ”¾åœºåœ°å¡”é˜²æ¸¸æˆ</h1>
    
    <div class="game-container">
        <canvas id="gameCanvas" width="800" height="600"></canvas>
        
        <div class="ui-panel">
            <div class="stats-section">
                <div class="section-title">æ¸¸æˆçŠ¶æ€</div>
                <div class="stat">ç”Ÿå‘½å€¼: <span id="health">20</span></div>
                <div class="stat">é‡‘å¸: <span id="money">100</span></div>
                <div class="stat">æ³¢æ¬¡: <span id="wave">1</span></div>
                <div class="stat">æ•Œäºº: <span id="enemies">0</span></div>
            </div>
            
            <div id="waveInfo" style="margin-bottom: 15px; font-size: 11px; background: rgba(0,0,0,0.3); padding: 6px; border-radius: 4px; display: none; max-height: 120px; overflow-y: auto;">
                <div class="section-title" style="margin-bottom: 3px; font-size: 12px;">å½“å‰æ³¢æ¬¡</div>
                <div id="waveComposition"></div>
            </div>
            
            <div id="powerUpEffects" style="margin-bottom: 15px; font-size: 11px; background: rgba(0,0,0,0.3); padding: 6px; border-radius: 4px; display: none; max-height: 100px; overflow-y: auto;">
                <div class="section-title" style="margin-bottom: 3px; font-size: 12px; color: #f1c40f;">æ¿€æ´»æ•ˆæœ</div>
            </div>
            
            <div class="towers-section">
                <div class="section-title">å»ºé€ å¡”æ¥¼</div>
                <div style="max-height: 200px; overflow-y: auto;">
                    <button class="tower-btn" id="basicTower">åŸºç¡€å¡” (20)</button>
                    <button class="tower-btn" id="fastTower">å¿«é€Ÿå¡” (30)</button>
                    <button class="tower-btn" id="heavyTower">é‡å‹å¡” (50)</button>
                    <button class="tower-btn" id="sniperTower">ç‹™å‡»å¡” (80)</button>
                    <button class="tower-btn" id="machineTower">æœºæªå¡” (60)</button>
                    <button class="tower-btn" id="laserTower">æ¿€å…‰å¡” (100)</button>
                    <button class="tower-btn" id="freezeTower">å†°å†»å¡” (45)</button>
                    <button class="tower-btn" id="poisonTower">æ¯’æ¶²å¡” (55)</button>
                    <button class="tower-btn" id="teslaTower">ç‰¹æ–¯æ‹‰å¡” (90)</button>
                    <button class="tower-btn" id="cannonTower">åŠ å†œç‚® (75)</button>
                    <button class="tower-btn" id="missileTower">å¯¼å¼¹å¡” (120)</button>
                </div>
                
                <button class="tower-btn wave-btn" id="pauseResume">æš‚åœæ¸¸æˆ</button>
                
                <div id="towerInfo" style="margin-top: 10px; font-size: 10px; background: rgba(0,0,0,0.3); padding: 5px; border-radius: 3px; display: none;">
                    <div id="towerName" style="font-weight: bold;"></div>
                    <div id="towerDescription"></div>
                    <div id="towerStats"></div>
                    <button class="tower-btn" id="upgradeTower" style="margin-top: 5px; display: none;">å‡çº§</button>
                    <button class="tower-btn" id="demolishTower" style="margin-top: 5px; display: none; background: #e74c3c;">æ‹†é™¤</button>
                </div>
            </div>
            
            <div class="notifications-area">
                <div class="notifications-title">æ¸¸æˆæç¤º</div>
                <div id="notifications">
                    <div class="notification">ç‚¹å‡»é€‰æ‹©å¡”ç±»å‹ï¼Œç„¶ååœ¨ç½‘æ ¼ä¸­æ”¾ç½®</div>
                    <div class="notification">é£è¡Œæ•Œäººä¼šç›´çº¿é£è¡Œï¼Œæ— è§†å¡”æ¥¼</div>
                    <div class="notification">æ¯5æ³¢å‡ºç°BOSSï¼Œæ¯10æ³¢å‡ºç°é£è¡ŒBOSS</div>
                </div>
            </div>
        </div>
    </div>
    
    <div class="game-over" id="gameOver">
        <h2>æ¸¸æˆç»“æŸ!</h2>
        <p>ä½ åšæŒäº† <span id="finalWave"></span> æ³¢</p>
        <button onclick="location.reload()">é‡æ–°å¼€å§‹</button>
    </div>

    <script>
        // æ¸¸æˆé…ç½®
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        
        // éŸ³æ•ˆç³»ç»Ÿ (æš‚æ—¶ç¦ç”¨ä»¥é¿å…è¯­æ³•é”™è¯¯)
        const soundEffects = {
            towerBuild: null,
            enemyDeath: null,
            powerUp: null,
            towerShoot: null
        };
        
        // æ’­æ”¾éŸ³æ•ˆå‡½æ•°
        function playSound(soundName, volume = 0.3) {
            try {
                const sound = soundEffects[soundName];
                if (sound) {
                    sound.volume = volume;
                    sound.currentTime = 0;
                    sound.play().catch(() => {}); // å¿½ç•¥æ’­æ”¾é”™è¯¯
                }
            } catch (e) {
                // å¿½ç•¥éŸ³æ•ˆé”™è¯¯
            }
        }
        const GRID_SIZE = 40;
        const GRID_COLS = canvas.width / GRID_SIZE;
        const GRID_ROWS = canvas.height / GRID_SIZE;
        
        // åˆ›å»ºç½‘æ ¼åœ°å›¾ (0=ç©ºåœ°, 1=å¡”æ¥¼, 2=èµ·ç‚¹, 3=ç»ˆç‚¹)
        let grid = [];
        for (let y = 0; y < GRID_ROWS; y++) {
            grid[y] = [];
            for (let x = 0; x < GRID_COLS; x++) {
                grid[y][x] = 0;
            }
        }
        // è®¾ç½®èµ·ç‚¹å’Œç»ˆç‚¹
        grid[1][0] = 2; // èµ·ç‚¹
        grid[1][1] = 2;
        grid[GRID_ROWS-2][GRID_COLS-1] = 3; // ç»ˆç‚¹
        grid[GRID_ROWS-2][GRID_COLS-2] = 3;
        
        // æ¸¸æˆçŠ¶æ€
        let gameState = {
            health: 20,
            money: 100,
            wave: 1,
            enemiesRemaining: 0,
            enemiesSpawned: 0,
            selectedTowerType: null,
            gameRunning: true,
            gamePaused: false,
            autoWave: true,
            waveStartDelay: 3000, // 3ç§’åè‡ªåŠ¨å¼€å§‹ä¸‹ä¸€æ³¢
            nextWaveTime: 0,
            towers: [],
            enemies: [],
            projectiles: [],
            powerUps: [],
            particles: [],
            waveInProgress: false,
            hoveredCell: null,
            score: 0,
            comboMultiplier: 1,
            lastKillTime: 0,
            killStreak: 0,
            damageBoostActive: false,
            damageBoostEndTime: 0,
            speedBoostActive: false,
            speedBoostEndTime: 0,
            freezeActive: false,
            freezeEndTime: 0,
            timeWarpActive: false,
            timeWarpEndTime: 0,
            goldRushActive: false,
            goldRushEndTime: 0,
            towerBoostActive: false,
            towerBoostEndTime: 0
        };
        
        // æ¸¸æˆç»Ÿè®¡
        let gameStats = {
            totalKills: 0,
            totalDamageDealt: 0,
            totalMoneyEarned: 0,
            towersBuilt: 0,
            towersUpgraded: 0,
            wavesCompleted: 0,
            bossesKilled: 0,
            perfectWaves: 0,
            longestKillStreak: 0,
            fastestWaveTime: Infinity,
            totalPlayTime: 0,
            gameStartTime: Date.now()
        };
        
        // æˆå°±ç³»ç»Ÿ
        const achievements = {
            firstKill: { 
                name: "é¦–æ¬¡å‡»æ€", description: "å‡»è´¥ç¬¬ä¸€ä¸ªæ•Œäºº", 
                unlocked: false, reward: 10, condition: () => gameStats.totalKills >= 1 
            },
            waveWarrior: { 
                name: "æ³¢æ¬¡å‹‡å£«", description: "å®Œæˆ10æ³¢æ•Œäºº", 
                unlocked: false, reward: 50, condition: () => gameStats.wavesCompleted >= 10 
            },
            bossSlayer: { 
                name: "BOSSæ€æ‰‹", description: "å‡»è´¥5ä¸ªBOSS", 
                unlocked: false, reward: 100, condition: () => gameStats.bossesKilled >= 5 
            },
            architect: { 
                name: "å»ºç­‘å¸ˆ", description: "å»ºé€ 50åº§å¡”æ¥¼", 
                unlocked: false, reward: 75, condition: () => gameStats.towersBuilt >= 50 
            },
            upgrader: { 
                name: "å‡çº§ä¸“å®¶", description: "å‡çº§25åº§å¡”æ¥¼", 
                unlocked: false, reward: 60, condition: () => gameStats.towersUpgraded >= 25 
            },
            millionaire: { 
                name: "ç™¾ä¸‡å¯Œç¿", description: "ç´¯è®¡è·å¾—1000é‡‘å¸", 
                unlocked: false, reward: 200, condition: () => gameStats.totalMoneyEarned >= 1000 
            },
            perfectionist: { 
                name: "å®Œç¾ä¸»ä¹‰è€…", description: "è¿ç»­5æ³¢ä¸å¤±è¡€", 
                unlocked: false, reward: 150, condition: () => gameStats.perfectWaves >= 5 
            },
            speedRunner: { 
                name: "é€Ÿåº¦ä¹‹ç‹", description: "30ç§’å†…å®Œæˆä¸€æ³¢", 
                unlocked: false, reward: 80, condition: () => gameStats.fastestWaveTime <= 30000 
            },
            chainKiller: { 
                name: "è¿ç¯æ€æ‰‹", description: "è¿ç»­å‡»æ€20ä¸ªæ•Œäºº", 
                unlocked: false, reward: 120, condition: () => gameStats.longestKillStreak >= 20 
            },
            survivor: { 
                name: "å¹¸å­˜è€…", description: "åšæŒåˆ°ç¬¬25æ³¢", 
                unlocked: false, reward: 300, condition: () => gameStats.wavesCompleted >= 25 
            }
        };
        
        // èƒ½é‡é“å…·ç±»å‹
        const powerUpTypes = {
            moneyBoost: { 
                name: "é‡‘å¸åŠ æˆ", color: '#f1c40f', duration: 300, 
                effect: () => { gameState.money += 50; }, 
                description: "+50é‡‘å¸" 
            },
            damageBoost: { 
                name: "ä¼¤å®³æå‡", color: '#e74c3c', duration: 600, 
                effect: () => { 
                    gameState.damageBoostActive = true;
                    gameState.damageBoostEndTime = Date.now() + 10000;
                }, 
                description: "ä¼¤å®³+50% (10ç§’)" 
            },
            speedBoost: { 
                name: "æ”»é€Ÿæå‡", color: '#3498db', duration: 600, 
                effect: () => { 
                    gameState.speedBoostActive = true;
                    gameState.speedBoostEndTime = Date.now() + 10000;
                }, 
                description: "æ”»é€Ÿ+100% (10ç§’)" 
            },
            healthRestore: { 
                name: "ç”Ÿå‘½æ¢å¤", color: '#2ecc71', duration: 60, 
                effect: () => { gameState.health = Math.min(20, gameState.health + 5); }, 
                description: "+5ç”Ÿå‘½å€¼" 
            },
            freeze: { 
                name: "æ—¶é—´å†»ç»“", color: '#9b59b6', duration: 300, 
                effect: () => { 
                    gameState.freezeActive = true;
                    gameState.freezeEndTime = Date.now() + 3000;
                }, 
                description: "å†»ç»“æ•Œäºº3ç§’" 
            },
            nuke: { 
                name: "æ ¸å¼¹æ‰“å‡»", color: '#ff5722', duration: 60, 
                effect: () => { 
                    gameState.enemies.forEach(enemy => enemy.takeDamage(enemy.hp * 0.5)); 
                }, 
                description: "å¯¹æ‰€æœ‰æ•Œäººé€ æˆ50%ä¼¤å®³" 
            },
            // æ–°èƒ½é‡é“å…·
            timeWarp: {
                name: "æ—¶é—´æ‰­æ›²", color: '#8e44ad', duration: 450,
                effect: () => {
                    gameState.timeWarpActive = true;
                    gameState.timeWarpEndTime = Date.now() + 7500; // 7.5ç§’
                    // å‡æ…¢æ‰€æœ‰æ•Œäººé€Ÿåº¦
                    gameState.enemies.forEach(enemy => {
                        enemy.originalSpeed = enemy.speed;
                        enemy.speed *= 0.3;
                    });
                },
                description: "å‡æ…¢æ•Œäººé€Ÿåº¦70% (7.5ç§’)"
            },
            goldRush: {
                name: "æ·˜é‡‘çƒ­", color: '#f1c40f', duration: 300,
                effect: () => {
                    gameState.goldRushActive = true;
                    gameState.goldRushEndTime = Date.now() + 5000; // 5ç§’
                },
                description: "å‡»æ€æ•Œäººè·å¾—åŒå€é‡‘å¸ (5ç§’)"
            },
            towerBoost: {
                name: "å¡”æ¥¼è¶…è½½", color: '#e74c3c', duration: 480,
                effect: () => {
                    gameState.towerBoostActive = true;
                    gameState.towerBoostEndTime = Date.now() + 8000; // 8ç§’
                    // ç«‹å³ç»™æ‰€æœ‰å¡”æ¥¼å……èƒ½
                    gameState.towers.forEach(tower => {
                        if (tower.config.energyCost) {
                            tower.energy = 100;
                        }
                    });
                },
                description: "å¡”æ¥¼æ”»å‡»é€Ÿåº¦+100% (8ç§’)"
            },
            shieldGenerator: {
                name: "æŠ¤ç›¾ç”Ÿæˆå™¨", color: '#3498db', duration: 180,
                effect: () => {
                    gameState.health += 3;
                    gameState.health = Math.min(20, gameState.health);
                    // æ·»åŠ æŠ¤ç›¾ç²’å­æ•ˆæœ
                    for (let i = 0; i < 15; i++) {
                        gameState.particles.push(new Particle(
                            canvas.width / 2, canvas.height / 2, 'shield', 
                            {color: '#3498db', life: 60, size: 4}
                        ));
                    }
                },
                description: "+3ç”Ÿå‘½å€¼"
            }
        };
        
        // ç²’å­æ•ˆæœç±»
        class Particle {
            constructor(x, y, type, data = {}) {
                this.x = x;
                this.y = y;
                this.type = type;
                this.life = data.life || 60;
                this.maxLife = this.life;
                this.vx = data.vx || (Math.random() - 0.5) * 4;
                this.vy = data.vy || (Math.random() - 0.5) * 4;
                this.color = data.color || '#ffffff';
                this.size = data.size || 2;
                this.gravity = data.gravity || 0;
            }
            
            update() {
                this.x += this.vx;
                this.y += this.vy;
                this.vy += this.gravity;
                this.life--;
                
                if (this.life <= 0) {
                    this.remove();
                }
            }
            
            draw() {
                const alpha = this.life / this.maxLife;
                ctx.save();
                ctx.globalAlpha = alpha;
                
                switch(this.type) {
                    case 'explosion':
                        ctx.fillStyle = this.color;
                        ctx.beginPath();
                        ctx.arc(this.x, this.y, this.size * (1 - alpha + 0.5), 0, Math.PI * 2);
                        ctx.fill();
                        break;
                    case 'smoke':
                        ctx.fillStyle = `rgba(100,100,100,${alpha * 0.5})`;
                        ctx.beginPath();
                        ctx.arc(this.x, this.y, this.size * (2 - alpha), 0, Math.PI * 2);
                        ctx.fill();
                        break;
                    case 'sparkle':
                        ctx.fillStyle = this.color;
                        ctx.fillRect(this.x - 1, this.y - 1, 2, 2);
                        ctx.fillRect(this.x - 3, this.y, 6, 1);
                        ctx.fillRect(this.x, this.y - 3, 1, 6);
                        break;
                    case 'money':
                        ctx.fillStyle = '#f1c40f';
                        ctx.font = '10px Arial';
                        ctx.textAlign = 'center';
                        ctx.fillText(`+${this.size}`, this.x, this.y);
                        ctx.textAlign = 'left';
                        break;
                    default:
                        ctx.fillStyle = this.color;
                        ctx.beginPath();
                        ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                        ctx.fill();
                }
                
                ctx.restore();
            }
            
            remove() {
                const index = gameState.particles.indexOf(this);
                if (index > -1) {
                    gameState.particles.splice(index, 1);
                }
            }
        }
        
        // èƒ½é‡é“å…·ç±»
        class PowerUp {
            constructor(x, y, type) {
                this.x = x;
                this.y = y;
                this.type = type;
                this.config = powerUpTypes[type];
                this.life = 600; // 10ç§’åæ¶ˆå¤±
                this.bobOffset = Math.random() * Math.PI * 2;
            }
            
            update() {
                this.life--;
                if (this.life <= 0) {
                    this.remove();
                }
                
                // æ£€æŸ¥ç©å®¶ç‚¹å‡»æ”¶é›†
                // è‡ªåŠ¨æ”¶é›†é€»è¾‘å¯ä»¥åœ¨è¿™é‡Œæ·»åŠ 
            }
            
            draw() {
                const bob = Math.sin(Date.now() * 0.01 + this.bobOffset) * 3;
                const alpha = this.life < 120 ? (this.life % 20) / 20 : 1;
                
                // æ£€æŸ¥é¼ æ ‡æ˜¯å¦æ‚¬åœåœ¨é“å…·ä¸Š
                const isHovered = this.isMouseOver();
                
                ctx.save();
                ctx.globalAlpha = alpha;
                
                // é¼ æ ‡æ‚¬åœæ—¶çš„é¢å¤–å…‰ç¯
                if (isHovered) {
                    ctx.fillStyle = 'rgba(255,255,255,0.3)';
                    ctx.beginPath();
                    ctx.arc(this.x, this.y + bob, 25, 0, Math.PI * 2);
                    ctx.fill();
                }
                
                // å…‰ç¯æ•ˆæœ
                ctx.fillStyle = this.config.color + '40';
                ctx.beginPath();
                ctx.arc(this.x, this.y + bob, 20, 0, Math.PI * 2);
                ctx.fill();
                
                // ä¸»ä½“
                ctx.fillStyle = this.config.color;
                ctx.beginPath();
                ctx.arc(this.x, this.y + bob, 8, 0, Math.PI * 2);
                ctx.fill();
                
                // é«˜å…‰
                ctx.fillStyle = 'rgba(255,255,255,0.8)';
                ctx.beginPath();
                ctx.arc(this.x - 2, this.y + bob - 2, 3, 0, Math.PI * 2);
                ctx.fill();
                
                // é¼ æ ‡æ‚¬åœæ—¶æ˜¾ç¤ºåç§°
                if (isHovered) {
                    ctx.fillStyle = 'white';
                    ctx.font = '12px Arial';
                    ctx.textAlign = 'center';
                    ctx.strokeStyle = 'black';
                    ctx.lineWidth = 2;
                    ctx.strokeText(this.config.name, this.x, this.y + bob - 30);
                    ctx.fillText(this.config.name, this.x, this.y + bob - 30);
                    ctx.textAlign = 'left';
                }
                
                ctx.restore();
            }
            
            isMouseOver() {
                // éœ€è¦å®é™…çš„é¼ æ ‡åæ ‡ï¼Œæš‚æ—¶ä½¿ç”¨ç®€åŒ–ç‰ˆæœ¬
                return false; // æš‚æ—¶ç¦ç”¨æ‚¬åœæ•ˆæœï¼Œå› ä¸ºéœ€è¦æ›´å¤æ‚çš„é¼ æ ‡åæ ‡è¿½è¸ª
            }
            
            collect() {
                this.config.effect();
                createCollectEffect(this.x, this.y, this.config.color);
                addNotification(`è·å¾—${this.config.name}! ${this.config.description}`);
                playSound('powerUp');
                this.remove();
            }
            
            remove() {
                const index = gameState.powerUps.indexOf(this);
                if (index > -1) {
                    gameState.powerUps.splice(index, 1);
                }
            }
        }
        
        // è§†è§‰æ•ˆæœå‡½æ•°
        function createDodgeEffect(x, y) {
            addNotification('èº²é¿ï¼');
            for(let i = 0; i < 5; i++) {
                gameState.particles.push(new Particle(x, y, 'sparkle', {
                    vx: (Math.random() - 0.5) * 6,
                    vy: (Math.random() - 0.5) * 6,
                    color: '#f1c40f',
                    life: 30,
                    size: 2
                }));
            }
        }
        
        function createShieldHitEffect(x, y) {
            for(let i = 0; i < 8; i++) {
                const angle = (i / 8) * Math.PI * 2;
                gameState.particles.push(new Particle(x, y, 'sparkle', {
                    vx: Math.cos(angle) * 4,
                    vy: Math.sin(angle) * 4,
                    color: '#3498db',
                    life: 25,
                    size: 3
                }));
            }
        }
        
        function createDeathEffect(x, y, color) {
            // çˆ†ç‚¸ç²’å­
            for(let i = 0; i < 12; i++) {
                gameState.particles.push(new Particle(x, y, 'explosion', {
                    vx: (Math.random() - 0.5) * 8,
                    vy: (Math.random() - 0.5) * 8,
                    color: color,
                    life: 40,
                    size: Math.random() * 4 + 2
                }));
            }
            
            // çƒŸé›¾æ•ˆæœ
            for(let i = 0; i < 6; i++) {
                gameState.particles.push(new Particle(x, y, 'smoke', {
                    vx: (Math.random() - 0.5) * 3,
                    vy: Math.random() * -2 - 1,
                    life: 60,
                    size: Math.random() * 3 + 3
                }));
            }
        }
        
        function createBossDeathEffect(x, y) {
            // è¶…å¤§çˆ†ç‚¸æ•ˆæœ
            for(let i = 0; i < 30; i++) {
                gameState.particles.push(new Particle(x, y, 'explosion', {
                    vx: (Math.random() - 0.5) * 12,
                    vy: (Math.random() - 0.5) * 12,
                    color: ['#e74c3c', '#f39c12', '#f1c40f'][Math.floor(Math.random() * 3)],
                    life: 80,
                    size: Math.random() * 8 + 4
                }));
            }
            
            // é‡‘è‰²å…‰ç¯
            for(let i = 0; i < 20; i++) {
                const angle = (i / 20) * Math.PI * 2;
                gameState.particles.push(new Particle(x, y, 'sparkle', {
                    vx: Math.cos(angle) * 6,
                    vy: Math.sin(angle) * 6,
                    color: '#f1c40f',
                    life: 60,
                    size: 4
                }));
            }
            
            addNotification('BOSSå·²è¢«å‡»è´¥ï¼');
        }
        
        function createMoneyEffect(x, y, amount) {
            gameState.particles.push(new Particle(x, y, 'money', {
                vx: 0,
                vy: -2,
                color: '#f1c40f',
                life: 90,
                size: amount
            }));
        }
        
        function createCollectEffect(x, y, color) {
            for(let i = 0; i < 15; i++) {
                const angle = (i / 15) * Math.PI * 2;
                gameState.particles.push(new Particle(x, y, 'sparkle', {
                    vx: Math.cos(angle) * 5,
                    vy: Math.sin(angle) * 5,
                    color: color,
                    life: 50,
                    size: 3
                }));
            }
        }
        
        // æˆå°±æ£€æŸ¥å‡½æ•°
        function checkAchievements() {
            Object.entries(achievements).forEach(([key, achievement]) => {
                if (!achievement.unlocked && achievement.condition()) {
                    achievement.unlocked = true;
                    gameState.money += achievement.reward;
                    addNotification(`ğŸ† æˆå°±è§£é”: ${achievement.name}! è·å¾—${achievement.reward}é‡‘å¸`);
                    
                    // æˆå°±è§£é”ç‰¹æ•ˆ
                    for(let i = 0; i < 20; i++) {
                        gameState.particles.push(new Particle(
                            canvas.width / 2 + (Math.random() - 0.5) * 100,
                            canvas.height / 2 + (Math.random() - 0.5) * 100,
                            'sparkle',
                            {
                                vx: (Math.random() - 0.5) * 4,
                                vy: (Math.random() - 0.5) * 4,
                                color: '#f1c40f',
                                life: 80,
                                size: 4
                            }
                        ));
                    }
                }
            });
        }
        
        // å¡”æ¥¼ç±»å‹
        const towerTypes = {
            // åŸºç¡€å¡”æ¥¼
            basic: { 
                cost: 20, damage: 15, range: 80, fireRate: 60, color: '#3498db', size: 15,
                name: 'åŸºç¡€å¡”', description: 'å¹³è¡¡çš„æ”»å‡»å’Œå°„ç¨‹'
            },
            fast: { 
                cost: 30, damage: 8, range: 60, fireRate: 20, color: '#f39c12', size: 12,
                name: 'å¿«é€Ÿå¡”', description: 'é«˜æ”»å‡»é¢‘ç‡'
            },
            heavy: { 
                cost: 50, damage: 35, range: 100, fireRate: 120, color: '#e74c3c', size: 18,
                name: 'é‡å‹å¡”', description: 'é«˜ä¼¤å®³è¿œç¨‹æ”»å‡»'
            },
            // ä¸“ä¸šå¡”æ¥¼
            sniper: {
                cost: 80, damage: 80, range: 200, fireRate: 180, color: '#34495e', size: 16,
                name: 'ç‹™å‡»å¡”', description: 'è¶…è¿œç¨‹ç²¾ç¡®æ‰“å‡»',
                piercing: true, critChance: 0.3
            },
            machine: {
                cost: 60, damage: 4, range: 70, fireRate: 8, color: '#e67e22', size: 14,
                name: 'æœºæªå¡”', description: 'è¶…é«˜æ”»å‡»é¢‘ç‡',
                multiShot: 3
            },
            laser: {
                cost: 100, damage: 25, range: 90, fireRate: 1, color: '#e74c3c', size: 17,
                name: 'æ¿€å…‰å¡”', description: 'æŒç»­æ¿€å…‰æŸæ”»å‡»',
                continuous: true, energyCost: 2
            },
            freeze: {
                cost: 45, damage: 5, range: 85, fireRate: 45, color: '#3498db', size: 15,
                name: 'å†°å†»å¡”', description: 'å‡é€Ÿæ•Œäºº',
                slowEffect: 0.5, slowDuration: 120
            },
            poison: {
                cost: 55, damage: 20, range: 75, fireRate: 80, color: '#27ae60', size: 16,
                name: 'æ¯’æ¶²å¡”', description: 'æŒç»­æ¯’ç´ ä¼¤å®³',
                poisonDamage: 3, poisonDuration: 180
            },
            tesla: {
                cost: 90, damage: 30, range: 95, fireRate: 100, color: '#9b59b6', size: 18,
                name: 'ç‰¹æ–¯æ‹‰å¡”', description: 'é“¾å¼é—ªç”µæ”»å‡»',
                chainLightning: 3, chainRange: 50
            },
            cannon: {
                cost: 75, damage: 60, range: 110, fireRate: 150, color: '#795548', size: 19,
                name: 'åŠ å†œç‚®', description: 'èŒƒå›´çˆ†ç‚¸ä¼¤å®³',
                explosive: true, explosionRadius: 40
            },
            missile: {
                cost: 120, damage: 100, range: 150, fireRate: 200, color: '#607d8b', size: 20,
                name: 'å¯¼å¼¹å¡”', description: 'è¿½è¸ªå¯¼å¼¹æ”»å‡»',
                homing: true, splashDamage: 50, splashRadius: 30
            },
            // æ”¯æ´å¡”æ¥¼
            buff: {
                cost: 40, damage: 0, range: 100, fireRate: 0, color: '#f1c40f', size: 14,
                name: 'å¢ç›Šå¡”', description: 'å¢å¼ºé™„è¿‘å¡”æ¥¼',
                buffRange: 120, damageBoost: 1.5, rangeBoost: 1.2, fireRateBoost: 1.3
            },
            repair: {
                cost: 35, damage: 0, range: 80, fireRate: 60, color: '#2ecc71', size: 13,
                name: 'ç»´ä¿®å¡”', description: 'æ¢å¤ç”Ÿå‘½å€¼',
                healing: 1, maxHealing: 5
            },
            shield: {
                cost: 70, damage: 0, range: 90, fireRate: 0, color: '#3498db', size: 16,
                name: 'æŠ¤ç›¾å¡”', description: 'ä¸ºåŸºåœ°æä¾›æŠ¤ç›¾',
                shieldStrength: 10, shieldRecharge: 1
            }
        };
        
        // æ•Œäººç±»å‹
        const enemyTypes = {
            basic: { 
                hp: 30, speed: 1, reward: 5, color: '#8e44ad', size: 8, 
                flying: false, boss: false, name: 'æ™®é€šå…µ'
            },
            fast: { 
                hp: 20, speed: 2, reward: 8, color: '#e67e22', size: 6,
                flying: false, boss: false, name: 'å¿«é€Ÿå…µ'
            },
            tank: { 
                hp: 80, speed: 0.5, reward: 15, color: '#2c3e50', size: 12,
                flying: false, boss: false, name: 'å¦å…‹å…µ'
            },
            flying: {
                hp: 25, speed: 1.5, reward: 12, color: '#3498db', size: 7,
                flying: true, boss: false, name: 'é£è¡Œå…µ'
            },
            heavy: {
                hp: 120, speed: 0.3, reward: 25, color: '#34495e', size: 14,
                flying: false, boss: false, name: 'é‡è£…å…µ'
            },
            stealth: {
                hp: 15, speed: 2.5, reward: 18, color: '#95a5a6', size: 6,
                flying: false, boss: false, name: 'éšèº«å…µ', stealth: true
            },
            // æ–°å¢æ•Œäººç±»å‹
            berserker: {
                hp: 50, speed: 0.8, reward: 20, color: '#c0392b', size: 10,
                flying: false, boss: false, name: 'ç‹‚æˆ˜å£«', 
                berserker: true // è¡€é‡è¶Šä½é€Ÿåº¦è¶Šå¿«
            },
            healer: {
                hp: 40, speed: 1.2, reward: 30, color: '#27ae60', size: 8,
                flying: false, boss: false, name: 'æ²»ç–—å…µ',
                healing: 5, healRange: 60 // æ²»ç–—é™„è¿‘æ•Œäºº
            },
            splitter: {
                hp: 35, speed: 1, reward: 15, color: '#f39c12', size: 9,
                flying: false, boss: false, name: 'åˆ†è£‚å…µ',
                splits: 2 // æ­»äº¡æ—¶åˆ†è£‚æˆå°å…µ
            },
            ghost: {
                hp: 20, speed: 1.8, reward: 25, color: '#bdc3c7', size: 7,
                flying: false, boss: false, name: 'å¹½çµå…µ',
                phase: true // å¯ä»¥ç©¿å¢™
            },
            shielded: {
                hp: 60, speed: 0.9, reward: 22, color: '#3498db', size: 10,
                flying: false, boss: false, name: 'æŠ¤ç›¾å…µ',
                shield: 40, shieldRegen: 1 // æŠ¤ç›¾ä¼šç¼“æ…¢æ¢å¤
            },
            swarm: {
                hp: 8, speed: 3, reward: 3, color: '#e67e22', size: 4,
                flying: false, boss: false, name: 'èœ‚ç¾¤å…µ'
            },
            poison: {
                hp: 45, speed: 1.1, reward: 28, color: '#16a085', size: 9,
                flying: false, boss: false, name: 'æ¯’æ¶²å…µ',
                poisonTrail: true // ç•™ä¸‹æ¯’æ¶²ç—•è¿¹å‡é€Ÿå¡”æ¥¼
            },
            // æ–°BOSS
            megaTank: {
                hp: 500, speed: 0.4, reward: 200, color: '#2c3e50', size: 25,
                flying: false, boss: true, name: 'è¶…çº§å¦å…‹',
                shield: 100, shieldRegen: 3, spawnsMinions: true
            },
            airCarrier: {
                hp: 350, speed: 1, reward: 250, color: '#9b59b6', size: 22,
                flying: true, boss: true, name: 'ç©ºä¸­æ¯èˆ°',
                spawnsFlyers: true, regeneration: 3
            },
            // ç»ˆæBOSS
            ancientEvil: {
                hp: 800, speed: 0.6, reward: 500, color: '#8e44ad', size: 30,
                flying: false, boss: true, name: 'è¿œå¤é‚ªæ¶',
                shield: 200, teleport: true, spawnsMinions: true, 
                phaseShift: true, regeneration: 5
            },
            boss: {
                hp: 300, speed: 0.8, reward: 100, color: '#e74c3c', size: 20,
                flying: false, boss: true, name: 'BOSS', shield: 50
            },
            flyingBoss: {
                hp: 250, speed: 1.2, reward: 150, color: '#9b59b6', size: 18,
                flying: true, boss: true, name: 'é£è¡ŒBOSS', regeneration: 2
            }
        };
        
        // æ¸¸æˆå¯¹è±¡ç±»
        class Tower {
            constructor(gridX, gridY, type) {
                this.gridX = gridX;
                this.gridY = gridY;
                this.x = gridX * GRID_SIZE + GRID_SIZE / 2;
                this.y = gridY * GRID_SIZE + GRID_SIZE / 2;
                this.type = type;
                this.config = towerTypes[type];
                this.level = 1;
                this.lastFire = 0;
                this.energy = 100; // ç”¨äºæ¿€å…‰å¡”ç­‰
                this.slowedEnemies = new Set(); // è·Ÿè¸ªè¢«å‡é€Ÿçš„æ•Œäºº
                this.poisonedEnemies = new Map(); // è·Ÿè¸ªè¢«æ¯’åŒ–çš„æ•Œäºº
                this.kills = 0; // å‡»æ€æ•°ç»Ÿè®¡
                
                // è®¡ç®—å®é™…å±æ€§ï¼ˆè€ƒè™‘å‡çº§ï¼‰
                this.calculateStats();
            }
            
            calculateStats() {
                const levelMultiplier = 1 + (this.level - 1) * 0.3;
                this.damage = Math.floor(this.config.damage * levelMultiplier);
                this.range = Math.floor(this.config.range * (1 + (this.level - 1) * 0.2));
                this.fireRate = Math.max(1, Math.floor(this.config.fireRate / (1 + (this.level - 1) * 0.2)));
            }
            
            upgrade() {
                if (this.level < 3) {
                    const upgradeCost = this.getUpgradeCost();
                    if (gameState.money >= upgradeCost) {
                        gameState.money -= upgradeCost;
                        this.level++;
                        this.calculateStats();
                        addNotification(`${this.config.name}å‡çº§åˆ°${this.level}çº§ï¼`);
                        updateUI();
                        return true;
                    }
                }
                return false;
            }
            
            applyBuffToNearbyTowers() {
                gameState.towers.forEach(otherTower => {
                    if (otherTower !== this) {
                        const dist = Math.sqrt((otherTower.x - this.x) ** 2 + (otherTower.y - this.y) ** 2);
                        if (dist <= this.config.buffRange) {
                            // åº”ç”¨å¢ç›Šæ•ˆæœ
                            otherTower.buffedDamage = this.config.damageBoost;
                            otherTower.buffedRange = this.config.rangeBoost;
                            otherTower.buffedFireRate = this.config.fireRateBoost;
                            otherTower.buffExpireTime = Date.now() + 2000; // 2ç§’åè¿‡æœŸ
                            
                            // æ·»åŠ å¢ç›Šç²’å­æ•ˆæœ
                            gameState.particles.push(new Particle(
                                otherTower.x, otherTower.y, 'buff', {color: '#f1c40f', life: 30, size: 3}
                            ));
                        }
                    }
                });
            }
            
            getUpgradeCost() {
                return Math.floor(this.config.cost * 0.6 * this.level);
            }
            
            update() {
                // èƒ½é‡ç³»ç»Ÿ
                if (this.config.energyCost && this.energy < 100) {
                    this.energy += 0.5; // ç¼“æ…¢æ¢å¤èƒ½é‡
                }
                
                // å¢ç›Šå¡”æ•ˆæœ - å¢å¼ºé™„è¿‘å¡”æ¥¼
                if (this.config.buffRange) {
                    this.buffTimer = (this.buffTimer || 0) + 1;
                    if (this.buffTimer >= 60) { // æ¯ç§’æ£€æµ‹ä¸€æ¬¡
                        this.applyBuffToNearbyTowers();
                        this.buffTimer = 0;
                    }
                }
                
                let effectiveFireRate = this.fireRate;
                if (gameState.speedBoostActive) {
                    effectiveFireRate /= 2; // æ”»é€Ÿæå‡100%
                }
                if (gameState.towerBoostActive) {
                    effectiveFireRate /= 2; // å¡”æ¥¼è¶…è½½å†æå‡100%
                }
                
                if (Date.now() - this.lastFire > effectiveFireRate * 16) {
                    const target = this.findTarget();
                    if (target) {
                        this.fire(target);
                        this.lastFire = Date.now();
                    }
                }
                
                // æŒç»­æ•ˆæœå¤„ç†
                this.updateContinuousEffects();
            }
            
            updateContinuousEffects() {
                // æ¿€å…‰å¡”æŒç»­æ”»å‡»
                if (this.config.continuous && this.energy >= this.config.energyCost) {
                    const target = this.findTarget();
                    if (target) {
                        target.takeDamage(this.damage / 60); // æ¯å¸§ä¼¤å®³
                        this.energy -= this.config.energyCost / 60;
                    }
                }
                
                // æ²»ç–—æ•ˆæœ
                if (this.config.healing && gameState.health < 20) {
                    if (Math.random() < 0.02) { // 2%æ¦‚ç‡æ²»ç–—
                        gameState.health = Math.min(20, gameState.health + this.config.healing);
                        updateUI();
                    }
                }
            }
            
            findTarget() {
                let effectiveRange = this.config.range;
                
                // å¢ç›Šå¡”èŒƒå›´åŠ æˆ
                if (this.buffedRange && Date.now() < this.buffExpireTime) {
                    effectiveRange *= this.buffedRange;
                }
                
                for (let enemy of gameState.enemies) {
                    const dist = Math.sqrt((enemy.x - this.x) ** 2 + (enemy.y - this.y) ** 2);
                    if (dist <= effectiveRange) {
                        return enemy;
                    }
                }
                return null;
            }
            
            fire(target) {
                // èƒ½é‡æ£€æŸ¥
                if (this.config.energyCost && this.energy < this.config.energyCost) {
                    return;
                }
                
                let damage = this.damage;
                
                // å¢ç›Šå¡”ä¼¤å®³åŠ æˆ
                if (this.buffedDamage && Date.now() < this.buffExpireTime) {
                    damage *= this.buffedDamage;
                }
                
                // æš´å‡»æœºåˆ¶
                if (this.config.critChance && Math.random() < this.config.critChance) {
                    damage *= 2;
                    addNotification('æš´å‡»ï¼');
                }
                
                // ä¼¤å®³æå‡æ•ˆæœ
                if (gameState.damageBoostActive) {
                    damage *= 1.5;
                }
                
                // å¤šå‘å°„å‡»
                if (this.config.multiShot) {
                    for (let i = 0; i < this.config.multiShot; i++) {
                        gameState.projectiles.push(new Projectile(this.x, this.y, target, damage, this.type));
                    }
                } else {
                    gameState.projectiles.push(new Projectile(this.x, this.y, target, damage, this.type));
                }
                
                // æ¶ˆè€—èƒ½é‡
                if (this.config.energyCost) {
                    this.energy -= this.config.energyCost;
                }
                
                // æ’­æ”¾å°„å‡»éŸ³æ•ˆï¼ˆéè¿ç»­æ”»å‡»çš„å¡”æ¥¼ï¼‰
                if (!this.config.continuous) {
                    playSound('towerShoot', 0.15);
                }
            }
            
            draw() {
                // ä½¿ç”¨2.5Dç»˜åˆ¶
                drawTower2D5(this);
                
                // ç­‰çº§æ ‡è¯†
                if (this.level > 1) {
                    ctx.fillStyle = '#f1c40f';
                    ctx.font = 'bold 10px Arial';
                    ctx.textAlign = 'center';
                    ctx.strokeStyle = 'black';
                    ctx.lineWidth = 3;
                    ctx.strokeText(`LV${this.level}`, this.x, this.y - this.config.size - 10);
                    ctx.fillText(`LV${this.level}`, this.x, this.y - this.config.size - 10);
                    ctx.textAlign = 'left';
                }
                
                // ç‰¹æ®Šæ•ˆæœæ ‡è¯†
                if (this.config.continuous) {
                    // æ¿€å…‰å¡”èƒ½é‡æ¡
                    const barWidth = 20;
                    const barHeight = 3;
                    const energyPercent = this.energy / 100;
                    
                    ctx.fillStyle = 'rgba(0,0,0,0.5)';
                    ctx.fillRect(this.x - barWidth/2, this.y + this.config.size + 8, barWidth, barHeight);
                    ctx.fillStyle = energyPercent > 0.5 ? '#2ecc71' : energyPercent > 0.2 ? '#f39c12' : '#e74c3c';
                    ctx.fillRect(this.x - barWidth/2, this.y + this.config.size + 8, barWidth * energyPercent, barHeight);
                    
                    // èƒ½é‡æ ‡ç­¾
                    ctx.fillStyle = 'white';
                    ctx.font = '6px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText('èƒ½é‡', this.x, this.y + this.config.size + 18);
                    ctx.textAlign = 'left';
                }
                
                // ç”»å°„ç¨‹åœˆï¼ˆå½“é€‰ä¸­æ—¶ï¼‰
                if (this === selectedTower) {
                    ctx.strokeStyle = 'rgba(255,255,255,0.4)';
                    ctx.lineWidth = 2;
                    ctx.setLineDash([5, 5]);
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, this.range, 0, Math.PI * 2);
                    ctx.stroke();
                    ctx.setLineDash([]);
                    
                    // æ˜¾ç¤ºå‡çº§ä¿¡æ¯
                    if (this.level < 3) {
                        ctx.fillStyle = 'white';
                        ctx.font = '9px Arial';
                        ctx.strokeStyle = 'black';
                        ctx.lineWidth = 2;
                        const upgradeText = `å‡çº§: ${this.getUpgradeCost()}é‡‘å¸`;
                        ctx.strokeText(upgradeText, this.x - 35, this.y + this.config.size + 25);
                        ctx.fillText(upgradeText, this.x - 35, this.y + this.config.size + 25);
                    } else {
                        ctx.fillStyle = '#f1c40f';
                        ctx.font = 'bold 9px Arial';
                        ctx.strokeStyle = 'black';
                        ctx.lineWidth = 2;
                        ctx.strokeText('æ»¡çº§', this.x - 12, this.y + this.config.size + 25);
                        ctx.fillText('æ»¡çº§', this.x - 12, this.y + this.config.size + 25);
                    }
                }
            }
        }
        
        class Enemy {
            constructor(type, waveNumber = 1) {
                this.type = type;
                this.config = enemyTypes[type];
                this.waveNumber = waveNumber;
                
                // æ ¹æ®æ³¢æ¬¡å¢å¼ºå±æ€§
                const waveMultiplier = 1 + (waveNumber - 1) * 0.15;
                this.hp = Math.floor(this.config.hp * waveMultiplier);
                this.maxHp = this.hp;
                this.speed = this.config.speed;
                this.originalSpeed = this.speed; // å­˜å‚¨åŸå§‹é€Ÿåº¦ç”¨äºå†»ç»“æ•ˆæœæ¢å¤
                this.reward = Math.floor(this.config.reward * (1 + (waveNumber - 1) * 0.1));
                
                // ç‰¹æ®Šå±æ€§
                this.shield = this.config.shield || 0;
                this.maxShield = this.shield;
                this.stealthTimer = 0;
                this.regenerationTimer = 0;
                
                // ä½ç½®åˆå§‹åŒ–
                this.gridX = 0;
                this.gridY = 1;
                this.x = this.gridX * GRID_SIZE + GRID_SIZE / 2;
                this.y = this.gridY * GRID_SIZE + GRID_SIZE / 2;
                this.path = [];
                this.pathIndex = 0;
                this.findPath();
            }
            
            findPath() {
                // ä¿å­˜å½“å‰ä½ç½®ä¿¡æ¯
                const currentGridX = Math.floor(this.x / GRID_SIZE);
                const currentGridY = Math.floor(this.y / GRID_SIZE);
                
                // é£è¡Œæ•Œäººç›´æ¥é£å‘ç»ˆç‚¹
                if (this.config.flying) {
                    this.path = [
                        {x: currentGridX, y: currentGridY},
                        {x: GRID_COLS-1, y: GRID_ROWS-2}
                    ];
                    this.pathIndex = 0;
                } else {
                    // ç¡®ä¿å½“å‰ä½ç½®åœ¨ç½‘æ ¼èŒƒå›´å†…
                    const safeGridX = Math.max(0, Math.min(GRID_COLS-1, currentGridX));
                    const safeGridY = Math.max(0, Math.min(GRID_ROWS-1, currentGridY));
                    
                    // ä½¿ç”¨å½“å‰ä½ç½®ä½œä¸ºèµ·ç‚¹é‡æ–°å¯»è·¯
                    const start = {x: safeGridX, y: safeGridY};
                    const end = {x: GRID_COLS-1, y: GRID_ROWS-2};
                    
                    // å¦‚æœå½“å‰ä½ç½®å°±æ˜¯ç»ˆç‚¹ï¼Œä¿æŒåŸæ ·
                    if (start.x === end.x && start.y === end.y) {
                        return;
                    }
                    
                    const newPath = aStarPathfinding(start, end, grid);
                    
                    if (newPath.length > 0) {
                        this.path = newPath;
                        this.pathIndex = 0;
                    } else {
                        // å¦‚æœæ‰¾ä¸åˆ°è·¯å¾„ï¼Œå°è¯•ä»åŸå§‹èµ·ç‚¹é‡æ–°å¯»è·¯
                        const fallbackPath = aStarPathfinding({x: 0, y: 1}, end, grid);
                        if (fallbackPath.length > 0) {
                            this.path = fallbackPath;
                            // æ‰¾åˆ°æœ€æ¥è¿‘å½“å‰ä½ç½®çš„è·¯å¾„ç‚¹
                            let bestIndex = 0;
                            let minDistance = Infinity;
                            
                            for (let i = 0; i < this.path.length; i++) {
                                const pathPoint = this.path[i];
                                const distance = Math.abs(pathPoint.x - currentGridX) + Math.abs(pathPoint.y - currentGridY);
                                
                                if (distance < minDistance) {
                                    minDistance = distance;
                                    bestIndex = i;
                                }
                            }
                            this.pathIndex = bestIndex;
                        }
                    }
                }
            }
            
            update() {
                // éšèº«æ•ˆæœå¤„ç†
                if (this.config.stealth) {
                    this.stealthTimer++;
                    if (this.stealthTimer > 180) { // 3ç§’éšèº«
                        this.stealthTimer = 0;
                    }
                }
                
                // ç”Ÿå‘½æ¢å¤æ•ˆæœ
                if (this.config.regeneration) {
                    this.regenerationTimer++;
                    if (this.regenerationTimer >= 60) { // æ¯ç§’æ¢å¤
                        this.hp = Math.min(this.maxHp, this.hp + this.config.regeneration);
                        this.regenerationTimer = 0;
                    }
                }
                
                // ç‹‚æˆ˜å£«æ•ˆæœ - è¡€é‡è¶Šä½é€Ÿåº¦è¶Šå¿«
                if (this.config.berserker) {
                    const healthRatio = this.hp / this.maxHp;
                    this.speed = this.originalSpeed * (1 + (1 - healthRatio) * 2); // æœ€é«˜3å€é€Ÿåº¦
                }
                
                // æ²»ç–—å…µæ•ˆæœ - æ²»ç–—é™„è¿‘æ•Œäºº
                if (this.config.healing) {
                    this.healingTimer = (this.healingTimer || 0) + 1;
                    if (this.healingTimer >= 120) { // æ¯2ç§’æ²»ç–—ä¸€æ¬¡
                        gameState.enemies.forEach(enemy => {
                            if (enemy !== this) {
                                const dist = Math.sqrt((enemy.x - this.x) ** 2 + (enemy.y - this.y) ** 2);
                                if (dist <= this.config.healRange) {
                                    enemy.hp = Math.min(enemy.maxHp, enemy.hp + this.config.healing);
                                    // æ·»åŠ æ²»ç–—ç²’å­æ•ˆæœ
                                    gameState.particles.push(new Particle(
                                        enemy.x, enemy.y, 'heal', {color: '#27ae60', life: 30}
                                    ));
                                }
                            }
                        });
                        this.healingTimer = 0;
                    }
                }
                
                // æŠ¤ç›¾æ¢å¤æ•ˆæœ
                if (this.config.shieldRegen && this.shield < this.maxShield) {
                    this.shieldRegenTimer = (this.shieldRegenTimer || 0) + 1;
                    if (this.shieldRegenTimer >= 60) { // æ¯ç§’æ¢å¤
                        this.shield = Math.min(this.maxShield, this.shield + this.config.shieldRegen);
                        this.shieldRegenTimer = 0;
                    }
                }
                
                // æ¯’æ¶²ç—•è¿¹æ•ˆæœ
                if (this.config.poisonTrail) {
                    this.poisonTrailTimer = (this.poisonTrailTimer || 0) + 1;
                    if (this.poisonTrailTimer >= 30) { // æ¯0.5ç§’ç•™ä¸‹æ¯’æ¶²
                        gameState.particles.push(new Particle(
                            this.x, this.y, 'poisonTrail', {color: '#16a085', life: 180, size: 3}
                        ));
                        this.poisonTrailTimer = 0;
                    }
                }
                
                // BOSSç”Ÿæˆå°å…µæ•ˆæœ
                if (this.config.boss && this.config.spawnsMinions) {
                    this.spawnMinionTimer = (this.spawnMinionTimer || 0) + 1;
                    if (this.spawnMinionTimer >= 300) { // æ¯5ç§’ç”Ÿæˆä¸€æ¬¡
                        this.spawnMinions();
                        this.spawnMinionTimer = 0;
                    }
                }
                
                // é£è¡ŒBOSSç”Ÿæˆé£è¡Œå…µ
                if (this.config.boss && this.config.spawnsFlyers) {
                    this.spawnFlyerTimer = (this.spawnFlyerTimer || 0) + 1;
                    if (this.spawnFlyerTimer >= 240) { // æ¯4ç§’ç”Ÿæˆä¸€æ¬¡
                        this.spawnFlyers();
                        this.spawnFlyerTimer = 0;
                    }
                }
                
                if (this.path.length === 0) {
                    this.findPath();
                    return;
                }
                
                if (this.pathIndex >= this.path.length) {
                    this.reachedEnd();
                    return;
                }
                
                const target = this.path[this.pathIndex];
                const targetX = target.x * GRID_SIZE + GRID_SIZE / 2;
                const targetY = target.y * GRID_SIZE + GRID_SIZE / 2;
                
                const dx = targetX - this.x;
                const dy = targetY - this.y;
                const dist = Math.sqrt(dx * dx + dy * dy);
                
                if (dist < 5) {
                    this.pathIndex++;
                } else {
                    this.x += (dx / dist) * this.speed;
                    this.y += (dy / dist) * this.speed;
                }
            }
            
            reachedEnd() {
                gameState.health--;
                addNotification(`${this.config.name}çªç ´äº†é˜²çº¿ï¼ç”Ÿå‘½å€¼-1`);
                this.remove();
                updateUI();
                
                if (gameState.health <= 0) {
                    endGame();
                }
            }
            
            takeDamage(damage, towerType = 'basic') {
                // éšèº«çŠ¶æ€ä¸‹æœ‰50%å‡ ç‡èº²é¿æ”»å‡»
                if (this.config.stealth && this.stealthTimer < 60 && Math.random() < 0.5) {
                    createDodgeEffect(this.x, this.y);
                    return;
                }
                
                // æŠ¤ç›¾å¸æ”¶ä¼¤å®³
                if (this.shield > 0) {
                    const shieldDamage = Math.min(this.shield, damage);
                    this.shield -= shieldDamage;
                    damage -= shieldDamage;
                    createShieldHitEffect(this.x, this.y);
                }
                
                // è®°å½•ä¼¤å®³ç»Ÿè®¡
                gameStats.totalDamageDealt += damage;
                
                this.hp -= damage;
                if (this.hp <= 0) {
                    this.onDeath();
                }
            }
            
            onDeath() {
                // æ­»äº¡å¥–åŠ±å’Œç»Ÿè®¡
                let reward = this.reward;
                
                // è¿å‡»ç³»ç»Ÿ
                const now = Date.now();
                if (now - gameState.lastKillTime < 2000) { // 2ç§’å†…è¿å‡»
                    gameState.killStreak++;
                    gameState.comboMultiplier = Math.min(3, 1 + gameState.killStreak * 0.1);
                    reward = Math.floor(reward * gameState.comboMultiplier);
                } else {
                    gameState.killStreak = 0;
                    gameState.comboMultiplier = 1;
                }
                gameState.lastKillTime = now;
                
                // æ·˜é‡‘çƒ­æ•ˆæœ - åŒå€é‡‘å¸
                if (gameState.goldRushActive) {
                    reward *= 2;
                }
                
                // æ›´æ–°ç»Ÿè®¡
                gameStats.totalKills++;
                gameStats.totalMoneyEarned += reward;
                gameStats.longestKillStreak = Math.max(gameStats.longestKillStreak, gameState.killStreak);
                
                if (this.config.boss) {
                    gameStats.bossesKilled++;
                    createBossDeathEffect(this.x, this.y);
                    // BOSSæ­»äº¡æœ‰æ¦‚ç‡æ‰è½é“å…·
                    if (Math.random() < 0.8) {
                        this.dropPowerUp();
                    }
                } else {
                    createDeathEffect(this.x, this.y, this.config.color);
                    // æ™®é€šæ•Œäººæœ‰å°æ¦‚ç‡æ‰è½é“å…·
                    if (Math.random() < 0.1) {
                        this.dropPowerUp();
                    }
                }
                
                gameState.money += reward;
                gameState.score += reward * 10;
                
                // æ˜¾ç¤ºè·å¾—é‡‘å¸æ•ˆæœ
                createMoneyEffect(this.x, this.y, reward);
                playSound('enemyDeath', 0.2);
                
                // åˆ†è£‚æ•ˆæœ
                if (this.config.splits && !this.config.boss) {
                    this.splitIntoSmallerEnemies();
                }
                
                this.remove();
                updateUI();
                checkAchievements();
            }
            
            splitIntoSmallerEnemies() {
                for (let i = 0; i < this.config.splits; i++) {
                    // åˆ›å»ºå°å‹çš„æ™®é€šæ•Œäºº
                    const smallEnemy = new Enemy('basic', this.waveNumber);
                    smallEnemy.x = this.x + (Math.random() - 0.5) * 20;
                    smallEnemy.y = this.y + (Math.random() - 0.5) * 20;
                    smallEnemy.hp = Math.floor(this.config.hp * 0.3); // 30%è¡€é‡
                    smallEnemy.maxHp = smallEnemy.hp;
                    smallEnemy.speed = this.config.speed * 1.5; // æ›´å¿«é€Ÿåº¦
                    smallEnemy.originalSpeed = smallEnemy.speed;
                    smallEnemy.reward = Math.floor(this.reward * 0.2); // 20%å¥–åŠ±
                    smallEnemy.path = [...this.path]; // å¤åˆ¶è·¯å¾„
                    smallEnemy.pathIndex = this.pathIndex;
                    
                    gameState.enemies.push(smallEnemy);
                    
                    // æ·»åŠ åˆ†è£‚ç²’å­æ•ˆæœ
                    gameState.particles.push(new Particle(
                        this.x, this.y, 'split', {color: '#f39c12', life: 40, size: 4}
                    ));
                }
                addNotification(`${this.config.name}åˆ†è£‚æˆäº†${this.config.splits}ä¸ªå°å…µï¼`);
            }
            
            spawnMinions() {
                const minionTypes = ['basic', 'fast', 'swarm'];
                const minionCount = 2 + Math.floor(this.waveNumber / 5); // éšæ³¢æ¬¡å¢åŠ 
                
                for (let i = 0; i < minionCount; i++) {
                    const minionType = minionTypes[Math.floor(Math.random() * minionTypes.length)];
                    const minion = new Enemy(minionType, this.waveNumber);
                    minion.x = this.x + (Math.random() - 0.5) * 40;
                    minion.y = this.y + (Math.random() - 0.5) * 40;
                    minion.path = [...this.path];
                    minion.pathIndex = this.pathIndex;
                    
                    gameState.enemies.push(minion);
                    
                    // æ·»åŠ ç”Ÿæˆç²’å­æ•ˆæœ
                    gameState.particles.push(new Particle(
                        this.x, this.y, 'spawn', {color: '#e74c3c', life: 50, size: 5}
                    ));
                }
                addNotification(`${this.config.name}å¬å”¤äº†${minionCount}ä¸ªå°å…µï¼`);
            }
            
            spawnFlyers() {
                const flyerCount = 1 + Math.floor(this.waveNumber / 8); // éšæ³¢æ¬¡å¢åŠ 
                
                for (let i = 0; i < flyerCount; i++) {
                    const flyer = new Enemy('flying', this.waveNumber);
                    flyer.x = this.x + (Math.random() - 0.5) * 50;
                    flyer.y = this.y + (Math.random() - 0.5) * 50;
                    flyer.path = [
                        {x: flyer.gridX, y: flyer.gridY},
                        {x: GRID_COLS-1, y: GRID_ROWS-2}
                    ];
                    flyer.pathIndex = 0;
                    
                    gameState.enemies.push(flyer);
                    
                    // æ·»åŠ ç”Ÿæˆç²’å­æ•ˆæœ
                    gameState.particles.push(new Particle(
                        this.x, this.y, 'spawn', {color: '#9b59b6', life: 50, size: 5}
                    ));
                }
                addNotification(`${this.config.name}å¬å”¤äº†${flyerCount}ä¸ªé£è¡Œå…µï¼`);
            }
            
            dropPowerUp() {
                const powerUpChances = [
                    'moneyBoost', 'damageBoost', 'speedBoost', 'healthRestore', 
                    'freeze', 'nuke', 'timeWarp', 'goldRush', 'towerBoost', 'shieldGenerator'
                ];
                const weights = [
                    30,  // moneyBoost
                    15,  // damageBoost
                    15,  // speedBoost
                    20,  // healthRestore
                    8,   // freeze
                    5,   // nuke
                    10,  // timeWarp
                    12,  // goldRush
                    10,  // towerBoost
                    15   // shieldGenerator
                ];
                
                // åŠ æƒéšæœºé€‰æ‹©
                let totalWeight = weights.reduce((sum, weight) => sum + weight, 0);
                let random = Math.random() * totalWeight;
                let weightSum = 0;
                
                for (let i = 0; i < powerUpChances.length; i++) {
                    weightSum += weights[i];
                    if (random <= weightSum) {
                        const randomPowerUp = powerUpChances[i];
                        gameState.powerUps.push(new PowerUp(this.x, this.y, randomPowerUp));
                        return;
                    }
                }
            }
            
            remove() {
                const index = gameState.enemies.indexOf(this);
                if (index > -1) {
                    gameState.enemies.splice(index, 1);
                }
            }
            
            draw() {
                // ä½¿ç”¨2.5Dç»˜åˆ¶
                drawEnemy2D5(this);
                
                // æŠ¤ç›¾æ¡
                if (this.maxShield > 0) {
                    const barWidth = 20;
                    const barHeight = 2;
                    const shieldPercent = this.shield / this.maxShield;
                    
                    ctx.fillStyle = 'rgba(52, 152, 219, 0.8)';
                    ctx.fillRect(this.x - barWidth/2, this.y - this.config.size - 12, barWidth, barHeight);
                    ctx.fillStyle = '#3498db';
                    ctx.fillRect(this.x - barWidth/2, this.y - this.config.size - 12, barWidth * shieldPercent, barHeight);
                }
                
                // è¡€æ¡
                const barWidth = Math.max(16, this.config.size * 1.5);
                const barHeight = 3;
                const hpPercent = this.hp / this.maxHp;
                
                ctx.fillStyle = 'rgba(0,0,0,0.5)';
                ctx.fillRect(this.x - barWidth/2, this.y - this.config.size - 8, barWidth, barHeight);
                ctx.fillStyle = hpPercent > 0.6 ? '#2ecc71' : hpPercent > 0.3 ? '#f39c12' : '#e74c3c';
                ctx.fillRect(this.x - barWidth/2, this.y - this.config.size - 8, barWidth * hpPercent, barHeight);
                
                // æ•Œäººåç§°ï¼ˆä»…BOSSï¼‰
                if (this.config.boss) {
                    ctx.fillStyle = 'white';
                    ctx.font = '8px Arial';
                    ctx.textAlign = 'center';
                    ctx.strokeStyle = 'black';
                    ctx.lineWidth = 2;
                    ctx.strokeText(this.config.name, this.x, this.y + this.config.size + 15);
                    ctx.fillText(this.config.name, this.x, this.y + this.config.size + 15);
                    ctx.textAlign = 'left';
                }
            }
        }
        
        class Projectile {
            constructor(x, y, target, damage, towerType = 'basic') {
                this.x = x;
                this.y = y;
                this.target = target;
                this.damage = damage;
                this.towerType = towerType;
                this.towerConfig = towerTypes[towerType];
                this.speed = this.towerConfig.homing ? 3 : 5;
                this.hasHit = false;
                this.chainCount = 0;
            }
            
            update() {
                // è¿½è¸ªå¯¼å¼¹é‡æ–°å¯»æ‰¾ç›®æ ‡
                if (this.towerConfig.homing && (!this.target || gameState.enemies.indexOf(this.target) === -1)) {
                    this.target = this.findNearestTarget();
                }
                
                if (!this.target) {
                    this.remove();
                    return;
                }
                
                const dx = this.target.x - this.x;
                const dy = this.target.y - this.y;
                const dist = Math.sqrt(dx * dx + dy * dy);
                
                if (dist < 5 && !this.hasHit) {
                    this.hit();
                } else {
                    this.x += (dx / dist) * this.speed;
                    this.y += (dy / dist) * this.speed;
                }
            }
            
            findNearestTarget() {
                let nearest = null;
                let minDist = Infinity;
                for (let enemy of gameState.enemies) {
                    const dist = Math.sqrt((enemy.x - this.x) ** 2 + (enemy.y - this.y) ** 2);
                    if (dist < minDist && dist < 200) {
                        minDist = dist;
                        nearest = enemy;
                    }
                }
                return nearest;
            }
            
            hit() {
                this.hasHit = true;
                
                // åŸºç¡€ä¼¤å®³
                this.target.takeDamage(this.damage, this.towerType);
                
                // ç‰¹æ®Šæ•ˆæœ
                this.applySpecialEffects();
                
                this.remove();
            }
            
            applySpecialEffects() {
                // çˆ†ç‚¸ä¼¤å®³
                if (this.towerConfig.explosive) {
                    this.dealExplosiveDamage();
                }
                
                // é“¾å¼é—ªç”µ
                if (this.towerConfig.chainLightning && this.chainCount < this.towerConfig.chainLightning) {
                    this.chainToNearbyEnemies();
                }
                
                // æº…å°„ä¼¤å®³
                if (this.towerConfig.splashDamage) {
                    this.dealSplashDamage();
                }
            }
            
            dealExplosiveDamage() {
                const radius = this.towerConfig.explosionRadius;
                gameState.enemies.forEach(enemy => {
                    const dist = Math.sqrt((enemy.x - this.target.x) ** 2 + (enemy.y - this.target.y) ** 2);
                    if (dist <= radius && enemy !== this.target) {
                        enemy.takeDamage(this.damage * 0.6, this.towerType);
                    }
                });
            }
            
            chainToNearbyEnemies() {
                const chainRange = this.towerConfig.chainRange;
                let nearestEnemy = null;
                let minDist = Infinity;
                
                gameState.enemies.forEach(enemy => {
                    if (enemy !== this.target) {
                        const dist = Math.sqrt((enemy.x - this.target.x) ** 2 + (enemy.y - this.target.y) ** 2);
                        if (dist <= chainRange && dist < minDist) {
                            minDist = dist;
                            nearestEnemy = enemy;
                        }
                    }
                });
                
                if (nearestEnemy) {
                    const chainProjectile = new Projectile(this.target.x, this.target.y, nearestEnemy, this.damage * 0.8, this.towerType);
                    chainProjectile.chainCount = this.chainCount + 1;
                    gameState.projectiles.push(chainProjectile);
                }
            }
            
            dealSplashDamage() {
                const radius = this.towerConfig.splashRadius;
                gameState.enemies.forEach(enemy => {
                    const dist = Math.sqrt((enemy.x - this.target.x) ** 2 + (enemy.y - this.target.y) ** 2);
                    if (dist <= radius && enemy !== this.target) {
                        enemy.takeDamage(this.towerConfig.splashDamage, this.towerType);
                    }
                });
            }
            
            remove() {
                const index = gameState.projectiles.indexOf(this);
                if (index > -1) {
                    gameState.projectiles.splice(index, 1);
                }
            }
            
            draw() {
                // æ ¹æ®å¡”æ¥¼ç±»å‹ç»˜åˆ¶ä¸åŒçš„å¼¹è¯
                switch(this.towerType) {
                    case 'sniper':
                        // ç‹™å‡»å­å¼¹
                        ctx.fillStyle = '#34495e';
                        ctx.fillRect(this.x - 1, this.y - 4, 2, 8);
                        break;
                    case 'machine':
                        // æœºæªå­å¼¹
                        ctx.fillStyle = '#e67e22';
                        ctx.beginPath();
                        ctx.arc(this.x, this.y, 2, 0, Math.PI * 2);
                        ctx.fill();
                        break;
                    case 'cannon':
                        // ç‚®å¼¹
                        ctx.fillStyle = '#795548';
                        ctx.beginPath();
                        ctx.arc(this.x, this.y, 5, 0, Math.PI * 2);
                        ctx.fill();
                        // æ‹–å°¾
                        ctx.fillStyle = 'rgba(255,100,0,0.5)';
                        ctx.beginPath();
                        ctx.arc(this.x - 3, this.y, 3, 0, Math.PI * 2);
                        ctx.fill();
                        break;
                    case 'missile':
                        // å¯¼å¼¹
                        ctx.fillStyle = '#607d8b';
                        ctx.fillRect(this.x - 2, this.y - 6, 4, 12);
                        ctx.fillStyle = '#ff5722';
                        ctx.beginPath();
                        ctx.arc(this.x, this.y - 6, 2, 0, Math.PI * 2);
                        ctx.fill();
                        // å°¾ç„°
                        ctx.fillStyle = 'rgba(255,100,0,0.8)';
                        ctx.beginPath();
                        ctx.arc(this.x, this.y + 6, 2, 0, Math.PI * 2);
                        ctx.fill();
                        break;
                    case 'tesla':
                        // ç”µå¼§
                        ctx.strokeStyle = '#9b59b6';
                        ctx.lineWidth = 3;
                        ctx.beginPath();
                        ctx.arc(this.x, this.y, 4, 0, Math.PI * 2);
                        ctx.stroke();
                        ctx.fillStyle = 'rgba(155,89,182,0.5)';
                        ctx.fill();
                        break;
                    case 'laser':
                        // æ¿€å…‰æŸ
                        ctx.strokeStyle = '#e74c3c';
                        ctx.lineWidth = 2;
                        ctx.beginPath();
                        ctx.arc(this.x, this.y, 2, 0, Math.PI * 2);
                        ctx.stroke();
                        ctx.fillStyle = 'rgba(231,76,60,0.8)';
                        ctx.fill();
                        break;
                    case 'freeze':
                        // å†°çƒ
                        ctx.fillStyle = '#3498db';
                        ctx.beginPath();
                        ctx.arc(this.x, this.y, 4, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.strokeStyle = '#ffffff';
                        ctx.lineWidth = 1;
                        ctx.stroke();
                        break;
                    case 'poison':
                        // æ¯’æ¶²çƒ
                        ctx.fillStyle = '#27ae60';
                        ctx.beginPath();
                        ctx.arc(this.x, this.y, 4, 0, Math.PI * 2);
                        ctx.fill();
                        // æ¯’æ¶²æ•ˆæœ
                        ctx.fillStyle = 'rgba(39,174,96,0.3)';
                        ctx.beginPath();
                        ctx.arc(this.x, this.y, 6, 0, Math.PI * 2);
                        ctx.fill();
                        break;
                    default:
                        // åŸºç¡€å¼¹è¯
                        drawShadow(this.x, this.y, 3, 0.2);
                        ctx.fillStyle = '#f1c40f';
                        ctx.beginPath();
                        ctx.arc(this.x, this.y, 3, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.fillStyle = 'rgba(255,255,255,0.6)';
                        ctx.beginPath();
                        ctx.arc(this.x - 1, this.y - 1, 1, 0, Math.PI * 2);
                        ctx.fill();
                }
            }
        }
        
        let selectedTower = null;
        
        // A*å¯»è·¯ç®—æ³•
        function aStarPathfinding(start, end, grid) {
            const openList = [];
            const closedList = [];
            
            const startNode = {
                x: start.x,
                y: start.y,
                g: 0,
                h: heuristic(start, end),
                f: 0,
                parent: null
            };
            startNode.f = startNode.g + startNode.h;
            openList.push(startNode);
            
            while (openList.length > 0) {
                // æ‰¾åˆ°få€¼æœ€å°çš„èŠ‚ç‚¹
                let currentNode = openList[0];
                let currentIndex = 0;
                for (let i = 1; i < openList.length; i++) {
                    if (openList[i].f < currentNode.f) {
                        currentNode = openList[i];
                        currentIndex = i;
                    }
                }
                
                // ä»å¼€æ”¾åˆ—è¡¨ç§»åˆ°å…³é—­åˆ—è¡¨
                openList.splice(currentIndex, 1);
                closedList.push(currentNode);
                
                // æ‰¾åˆ°ç»ˆç‚¹
                if (currentNode.x === end.x && currentNode.y === end.y) {
                    const path = [];
                    let current = currentNode;
                    while (current) {
                        path.unshift({x: current.x, y: current.y});
                        current = current.parent;
                    }
                    return path;
                }
                
                // æ£€æŸ¥ç›¸é‚»èŠ‚ç‚¹
                const neighbors = [
                    {x: currentNode.x + 1, y: currentNode.y},
                    {x: currentNode.x - 1, y: currentNode.y},
                    {x: currentNode.x, y: currentNode.y + 1},
                    {x: currentNode.x, y: currentNode.y - 1}
                ];
                
                for (let neighbor of neighbors) {
                    // æ£€æŸ¥è¾¹ç•Œå’Œéšœç¢ç‰©
                    if (neighbor.x < 0 || neighbor.x >= GRID_COLS || 
                        neighbor.y < 0 || neighbor.y >= GRID_ROWS ||
                        grid[neighbor.y][neighbor.x] === 1) {
                        continue;
                    }
                    
                    // æ£€æŸ¥æ˜¯å¦åœ¨å…³é—­åˆ—è¡¨ä¸­
                    if (closedList.find(node => node.x === neighbor.x && node.y === neighbor.y)) {
                        continue;
                    }
                    
                    const g = currentNode.g + 1;
                    const h = heuristic(neighbor, end);
                    const f = g + h;
                    
                    // æ£€æŸ¥æ˜¯å¦åœ¨å¼€æ”¾åˆ—è¡¨ä¸­
                    const existingNode = openList.find(node => node.x === neighbor.x && node.y === neighbor.y);
                    if (existingNode) {
                        if (g < existingNode.g) {
                            existingNode.g = g;
                            existingNode.f = f;
                            existingNode.parent = currentNode;
                        }
                    } else {
                        openList.push({
                            x: neighbor.x,
                            y: neighbor.y,
                            g: g,
                            h: h,
                            f: f,
                            parent: currentNode
                        });
                    }
                }
            }
            
            // æ²¡æœ‰æ‰¾åˆ°è·¯å¾„
            return [];
        }
        
        function heuristic(a, b) {
            return Math.abs(a.x - b.x) + Math.abs(a.y - b.y);
        }
        
        // ç½‘æ ¼åæ ‡è½¬æ¢
        function screenToGrid(x, y) {
            return {
                x: Math.floor(x / GRID_SIZE),
                y: Math.floor(y / GRID_SIZE)
            };
        }
        
        function gridToScreen(gridX, gridY) {
            return {
                x: gridX * GRID_SIZE + GRID_SIZE / 2,
                y: gridY * GRID_SIZE + GRID_SIZE / 2
            };
        }
        
        // 2.5Dç»˜åˆ¶å·¥å…·å‡½æ•°
        function drawShadow(x, y, size, opacity = 0.3) {
            ctx.save();
            ctx.globalAlpha = opacity;
            ctx.fillStyle = '#000000';
            ctx.beginPath();
            ctx.ellipse(x + 2, y + size + 3, size * 0.8, size * 0.3, 0, 0, Math.PI * 2);
            ctx.fill();
            ctx.restore();
        }
        
        function draw3DCircle(x, y, size, color, highlightColor = null) {
            // é˜´å½±
            drawShadow(x, y, size);
            
            // ä¸»ä½“
            const gradient = ctx.createRadialGradient(x - size * 0.3, y - size * 0.3, 0, x, y, size);
            gradient.addColorStop(0, highlightColor || lightenColor(color, 40));
            gradient.addColorStop(0.7, color);
            gradient.addColorStop(1, darkenColor(color, 30));
            
            ctx.fillStyle = gradient;
            ctx.beginPath();
            ctx.arc(x, y, size, 0, Math.PI * 2);
            ctx.fill();
            
            // é«˜å…‰
            ctx.fillStyle = 'rgba(255,255,255,0.4)';
            ctx.beginPath();
            ctx.arc(x - size * 0.3, y - size * 0.3, size * 0.3, 0, Math.PI * 2);
            ctx.fill();
        }
        
        function draw3DRect(x, y, width, height, color) {
            // é˜´å½±
            ctx.fillStyle = 'rgba(0,0,0,0.3)';
            ctx.fillRect(x + 2, y + height + 1, width, 3);
            
            // ä¾§é¢
            ctx.fillStyle = darkenColor(color, 20);
            ctx.fillRect(x + width, y + 2, 3, height);
            
            // ä¸»ä½“
            const gradient = ctx.createLinearGradient(x, y, x, y + height);
            gradient.addColorStop(0, lightenColor(color, 20));
            gradient.addColorStop(1, color);
            ctx.fillStyle = gradient;
            ctx.fillRect(x, y, width, height);
            
            // é¡¶éƒ¨é«˜å…‰
            ctx.fillStyle = lightenColor(color, 30);
            ctx.fillRect(x, y, width, 2);
        }
        
        function lightenColor(color, percent) {
            const num = parseInt(color.replace("#",""), 16);
            const amt = Math.round(2.55 * percent);
            const R = (num >> 16) + amt;
            const G = (num >> 8 & 0x00FF) + amt;
            const B = (num & 0x0000FF) + amt;
            return "#" + (0x1000000 + (R<255?R<1?0:R:255)*0x10000 + 
                    (G<255?G<1?0:G:255)*0x100 + (B<255?B<1?0:B:255))
                    .toString(16).slice(1);
        }
        
        function darkenColor(color, percent) {
            const num = parseInt(color.replace("#",""), 16);
            const amt = Math.round(2.55 * percent);
            const R = (num >> 16) - amt;
            const G = (num >> 8 & 0x00FF) - amt;
            const B = (num & 0x0000FF) - amt;
            return "#" + (0x1000000 + (R>0?R:0)*0x10000 + 
                    (G>0?G:0)*0x100 + (B>0?B:0))
                    .toString(16).slice(1);
        }
        
        // æ•Œäºº2.5Dç»˜åˆ¶å‡½æ•°
        function drawEnemy2D5(enemy) {
            const x = enemy.x;
            const y = enemy.y;
            const size = enemy.config.size;
            const color = enemy.config.color;
            
            switch(enemy.type) {
                case 'basic':
                    drawBasicSoldier(x, y, size, color);
                    break;
                case 'fast':
                    drawFastSoldier(x, y, size, color);
                    break;
                case 'tank':
                    drawTankSoldier(x, y, size, color);
                    break;
                case 'flying':
                    drawFlyingSoldier(x, y, size, color);
                    break;
                case 'heavy':
                    drawHeavySoldier(x, y, size, color);
                    break;
                case 'stealth':
                    drawStealthSoldier(x, y, size, color, enemy.stealthTimer < 60);
                    break;
                case 'berserker':
                    drawBerserker(x, y, size, color, enemy.hp / enemy.maxHp);
                    break;
                case 'healer':
                    drawHealer(x, y, size, color);
                    break;
                case 'splitter':
                    drawSplitter(x, y, size, color);
                    break;
                case 'ghost':
                    drawGhost(x, y, size, color);
                    break;
                case 'shielded':
                    drawShielded(x, y, size, color, enemy.shield > 0);
                    break;
                case 'swarm':
                    drawSwarm(x, y, size, color);
                    break;
                case 'poison':
                    drawPoison(x, y, size, color);
                    break;
                case 'boss':
                    drawBoss(x, y, size, color);
                    break;
                case 'flyingBoss':
                    drawFlyingBoss(x, y, size, color);
                    break;
                case 'megaTank':
                    drawMegaTank(x, y, size, color);
                    break;
                case 'airCarrier':
                    drawAirCarrier(x, y, size, color);
                    break;
                case 'ancientEvil':
                    drawAncientEvil(x, y, size, color);
                    break;
                default:
                    draw3DCircle(x, y, size, color);
            }
        }
        
        // åŸºç¡€å£«å…µ - ç®€å•çš„åœ†å½¢æˆ˜å£«
        function drawBasicSoldier(x, y, size, color) {
            draw3DCircle(x, y, size, color);
            // ç›”ç”²çº¿æ¡
            ctx.strokeStyle = darkenColor(color, 20);
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.arc(x, y, size * 0.8, 0, Math.PI * 2);
            ctx.stroke();
        }
        
        // å¿«é€Ÿå£«å…µ - æµçº¿å‹
        function drawFastSoldier(x, y, size, color) {
            drawShadow(x, y, size);
            
            // ä¸»ä½“æ¤­åœ†
            ctx.fillStyle = color;
            ctx.beginPath();
            ctx.ellipse(x, y, size, size * 0.7, 0, 0, Math.PI * 2);
            ctx.fill();
            
            // é€Ÿåº¦çº¿æ¡
            ctx.strokeStyle = lightenColor(color, 30);
            ctx.lineWidth = 2;
            for(let i = 0; i < 3; i++) {
                ctx.beginPath();
                ctx.moveTo(x - size - 5 - i * 3, y - 2 + i * 2);
                ctx.lineTo(x - size + 2 - i * 3, y - 2 + i * 2);
                ctx.stroke();
            }
        }
        
        // å¦å…‹å£«å…µ - æ–¹å½¢è£…ç”²
        function drawTankSoldier(x, y, size, color) {
            draw3DRect(x - size, y - size, size * 2, size * 2, color);
            
            // è£…ç”²æ¿
            ctx.fillStyle = lightenColor(color, 20);
            ctx.fillRect(x - size * 0.7, y - size * 0.7, size * 1.4, size * 0.3);
            ctx.fillRect(x - size * 0.7, y + size * 0.4, size * 1.4, size * 0.3);
        }
        
        // é£è¡Œå£«å…µ - å¸¦ç¿…è†€
        function drawFlyingSoldier(x, y, size, color) {
            // ç¿…è†€åŠ¨ç”»
            const wingOffset = Math.sin(Date.now() * 0.01) * 2;
            
            // ç¿…è†€
            ctx.fillStyle = 'rgba(255,255,255,0.7)';
            ctx.beginPath();
            ctx.ellipse(x - size * 0.8, y + wingOffset, size * 0.6, size * 0.3, -0.3, 0, Math.PI * 2);
            ctx.ellipse(x + size * 0.8, y + wingOffset, size * 0.6, size * 0.3, 0.3, 0, Math.PI * 2);
            ctx.fill();
            
            // èº«ä½“
            draw3DCircle(x, y - 2, size * 0.8, color);
        }
        
        // é‡è£…å£«å…µ - è¶…å¤§è£…ç”²
        function drawHeavySoldier(x, y, size, color) {
            draw3DRect(x - size, y - size, size * 2, size * 2, color);
            
            // å¤šå±‚è£…ç”²
            ctx.strokeStyle = darkenColor(color, 30);
            ctx.lineWidth = 2;
            ctx.strokeRect(x - size * 0.8, y - size * 0.8, size * 1.6, size * 1.6);
            ctx.strokeRect(x - size * 0.6, y - size * 0.6, size * 1.2, size * 1.2);
        }
        
        // éšèº«å£«å…µ - åŠé€æ˜æ•ˆæœ
        function drawStealthSoldier(x, y, size, color, isStealthed) {
            ctx.save();
            if (isStealthed) {
                ctx.globalAlpha = 0.3;
                // æ‰­æ›²æ•ˆæœ
                for(let i = 0; i < 3; i++) {
                    ctx.strokeStyle = 'rgba(200,200,255,0.3)';
                    ctx.lineWidth = 1;
                    ctx.beginPath();
                    ctx.arc(x + Math.sin(Date.now() * 0.01 + i) * 2, y, size + i, 0, Math.PI * 2);
                    ctx.stroke();
                }
            }
            draw3DCircle(x, y, size, color);
            ctx.restore();
        }
        
        // ç‹‚æˆ˜å£« - çº¢è‰²å…‰ç¯éšè¡€é‡å˜åŒ–
        function drawBerserker(x, y, size, color, hpPercent) {
            const rage = 1 - hpPercent;
            
            // æ„¤æ€’å…‰ç¯
            if (rage > 0.3) {
                ctx.fillStyle = `rgba(255,0,0,${rage * 0.5})`;
                ctx.beginPath();
                ctx.arc(x, y, size * (1 + rage), 0, Math.PI * 2);
                ctx.fill();
            }
            
            draw3DCircle(x, y, size, color);
            
            // æ„¤æ€’çº¿æ¡
            ctx.strokeStyle = '#ff0000';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(x - size, y);
            ctx.lineTo(x + size, y);
            ctx.moveTo(x, y - size);
            ctx.lineTo(x, y + size);
            ctx.stroke();
        }
        
        // æ²»ç–—å…µ - åå­—æ ‡å¿—
        function drawHealer(x, y, size, color) {
            draw3DCircle(x, y, size, color);
            
            // æ²»ç–—åå­—
            ctx.fillStyle = '#ffffff';
            ctx.fillRect(x - size * 0.6, y - size * 0.2, size * 1.2, size * 0.4);
            ctx.fillRect(x - size * 0.2, y - size * 0.6, size * 0.4, size * 1.2);
            
            // æ²»ç–—å…‰ç¯
            ctx.strokeStyle = 'rgba(39,174,96,0.5)';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.arc(x, y, size * 1.5, 0, Math.PI * 2);
            ctx.stroke();
        }
        
        // åˆ†è£‚å…µ - è£‚ç¼æ•ˆæœ
        function drawSplitter(x, y, size, color) {
            draw3DCircle(x, y, size, color);
            
            // è£‚ç¼
            ctx.strokeStyle = darkenColor(color, 40);
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(x - size * 0.8, y - size * 0.3);
            ctx.lineTo(x + size * 0.8, y + size * 0.3);
            ctx.moveTo(x - size * 0.3, y - size * 0.8);
            ctx.lineTo(x + size * 0.3, y + size * 0.8);
            ctx.stroke();
        }
        
        // å¹½çµå…µ - é£˜æ¸ºæ•ˆæœ
        function drawGhost(x, y, size, color) {
            ctx.save();
            ctx.globalAlpha = 0.7;
            
            // å¹½çµå°¾å·´
            for(let i = 0; i < 5; i++) {
                ctx.globalAlpha = 0.7 - i * 0.1;
                draw3DCircle(x - i * 2, y + i, size - i, color);
            }
            
            ctx.restore();
        }
        
        // æŠ¤ç›¾å…µ - æŠ¤ç›¾æ•ˆæœ
        function drawShielded(x, y, size, color, hasShield) {
            draw3DCircle(x, y, size, color);
            
            if (hasShield) {
                // æŠ¤ç›¾
                ctx.strokeStyle = '#3498db';
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.arc(x, y, size * 1.3, 0, Math.PI * 2);
                ctx.stroke();
                
                // æŠ¤ç›¾å…‰æ³½
                ctx.strokeStyle = 'rgba(52,152,219,0.3)';
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.arc(x - size * 0.3, y - size * 0.3, size * 1.3, 0, Math.PI);
                ctx.stroke();
            }
        }
        
        // èœ‚ç¾¤å…µ - å°ä¸‰è§’å½¢
        function drawSwarm(x, y, size, color) {
            drawShadow(x, y, size);
            
            ctx.fillStyle = color;
            ctx.beginPath();
            ctx.moveTo(x, y - size);
            ctx.lineTo(x - size * 0.8, y + size * 0.5);
            ctx.lineTo(x + size * 0.8, y + size * 0.5);
            ctx.closePath();
            ctx.fill();
            
            // ç¿…è†€æŒ¯åŠ¨
            ctx.strokeStyle = 'rgba(255,255,255,0.6)';
            ctx.lineWidth = 1;
            const wingBuzz = Math.sin(Date.now() * 0.02) * size * 0.3;
            ctx.beginPath();
            ctx.moveTo(x - size * 0.5, y);
            ctx.lineTo(x - size * 1.2 + wingBuzz, y - size * 0.3);
            ctx.moveTo(x + size * 0.5, y);
            ctx.lineTo(x + size * 1.2 + wingBuzz, y - size * 0.3);
            ctx.stroke();
        }
        
        // æ¯’æ¶²å…µ - æ³¡æ³¡æ•ˆæœ
        function drawPoison(x, y, size, color) {
            draw3DCircle(x, y, size, color);
            
            // æ¯’æ³¡
            for(let i = 0; i < 3; i++) {
                const bubbleX = x + (Math.sin(Date.now() * 0.01 + i) * size * 0.5);
                const bubbleY = y + (Math.cos(Date.now() * 0.01 + i) * size * 0.5);
                ctx.fillStyle = 'rgba(22,160,133,0.6)';
                ctx.beginPath();
                ctx.arc(bubbleX, bubbleY, size * 0.2, 0, Math.PI * 2);
                ctx.fill();
            }
        }
        
        // BOSS - è¶…å¤§è£…ç”²
        function drawBoss(x, y, size, color) {
            draw3DRect(x - size, y - size, size * 2, size * 2, color);
            
            // é‡‘è‰²è¾¹æ¡†
            ctx.strokeStyle = '#f1c40f';
            ctx.lineWidth = 3;
            ctx.strokeRect(x - size * 0.9, y - size * 0.9, size * 1.8, size * 1.8);
            
            // èƒ½é‡æ ¸å¿ƒ
            ctx.fillStyle = '#ff0000';
            ctx.beginPath();
            ctx.arc(x, y, size * 0.3, 0, Math.PI * 2);
            ctx.fill();
        }
        
        // é£è¡ŒBOSS - å¤§å‹é£è¡Œå™¨
        function drawFlyingBoss(x, y, size, color) {
            // ä¸»ä½“
            draw3DCircle(x, y - 3, size, color);
            
            // å¤§ç¿…è†€
            ctx.fillStyle = darkenColor(color, 20);
            ctx.beginPath();
            ctx.ellipse(x - size * 1.2, y, size * 0.8, size * 0.4, -0.2, 0, Math.PI * 2);
            ctx.ellipse(x + size * 1.2, y, size * 0.8, size * 0.4, 0.2, 0, Math.PI * 2);
            ctx.fill();
            
            // èƒ½é‡æ¨è¿›å™¨
            ctx.fillStyle = '#3498db';
            ctx.beginPath();
            ctx.arc(x, y + size * 0.8, size * 0.2, 0, Math.PI * 2);
            ctx.fill();
        }
        
        // è¶…çº§å¦å…‹ - å·¨å‹è£…ç”²
        function drawMegaTank(x, y, size, color) {
            // å±¥å¸¦
            ctx.fillStyle = darkenColor(color, 30);
            ctx.fillRect(x - size * 1.2, y + size * 0.8, size * 2.4, size * 0.4);
            
            // ä¸»ä½“
            draw3DRect(x - size, y - size, size * 2, size * 1.8, color);
            
            // ç‚®å¡”
            draw3DCircle(x, y - size * 0.2, size * 0.7, darkenColor(color, 10));
            
            // ç‚®ç®¡
            ctx.fillStyle = darkenColor(color, 20);
            ctx.fillRect(x + size * 0.7, y - size * 0.3, size * 0.8, size * 0.2);
        }
        
        // ç©ºä¸­æ¯èˆ° - å¤§å‹é£èˆ¹
        function drawAirCarrier(x, y, size, color) {
            // ä¸»ä½“èˆ¹èº«
            ctx.fillStyle = color;
            ctx.beginPath();
            ctx.ellipse(x, y, size * 1.2, size * 0.6, 0, 0, Math.PI * 2);
            ctx.fill();
            
            // ç”²æ¿
            ctx.fillStyle = lightenColor(color, 20);
            ctx.fillRect(x - size, y - size * 0.2, size * 2, size * 0.4);
            
            // èˆ°å²›
            draw3DRect(x + size * 0.5, y - size * 0.8, size * 0.4, size * 0.6, darkenColor(color, 10));
            
            // æ¨è¿›å™¨å…‰èŠ’
            ctx.fillStyle = '#3498db';
            ctx.beginPath();
            ctx.arc(x - size * 1.2, y, size * 0.1, 0, Math.PI * 2);
            ctx.fill();
        }
        
        // è¿œå¤é‚ªæ¶ - ç¥ç§˜ç¬¦æ–‡
        function drawAncientEvil(x, y, size, color) {
            // ä¸»ä½“
            draw3DCircle(x, y, size, color);
            
            // é‚ªæ¶å…‰ç¯
            const time = Date.now() * 0.005;
            for(let i = 0; i < 3; i++) {
                ctx.strokeStyle = `rgba(142,68,173,${0.3 + Math.sin(time + i) * 0.2})`;
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.arc(x, y, size * (1.5 + i * 0.3), 0, Math.PI * 2);
                ctx.stroke();
            }
            
            // ç¬¦æ–‡
            ctx.strokeStyle = '#f1c40f';
            ctx.lineWidth = 2;
            ctx.beginPath();
            // äº”è§’æ˜Ÿ
            for(let i = 0; i < 5; i++) {
                const angle = (i * 72 - 90) * Math.PI / 180;
                const px = x + Math.cos(angle) * size * 0.6;
                const py = y + Math.sin(angle) * size * 0.6;
                if(i === 0) ctx.moveTo(px, py);
                else ctx.lineTo(px, py);
            }
            ctx.closePath();
            ctx.stroke();
        }
        
        // å¡”æ¥¼2.5Dç»˜åˆ¶å‡½æ•°
        function drawTower2D5(tower) {
            const x = tower.x;
            const y = tower.y;
            const size = tower.config.size;
            const color = tower.config.color;
            
            switch(tower.type) {
                case 'basic':
                    drawBasicTower(x, y, size, color);
                    break;
                case 'fast':
                    drawFastTower(x, y, size, color);
                    break;
                case 'heavy':
                    drawHeavyTower(x, y, size, color);
                    break;
                case 'sniper':
                    drawSniperTower(x, y, size, color);
                    break;
                case 'machine':
                    drawMachineTower(x, y, size, color);
                    break;
                case 'laser':
                    drawLaserTower(x, y, size, color, tower.energy);
                    break;
                case 'freeze':
                    drawFreezeTower(x, y, size, color);
                    break;
                case 'poison':
                    drawPoisonTower(x, y, size, color);
                    break;
                case 'tesla':
                    drawTeslaTower(x, y, size, color);
                    break;
                case 'cannon':
                    drawCannonTower(x, y, size, color);
                    break;
                case 'missile':
                    drawMissileTower(x, y, size, color);
                    break;
                case 'buff':
                    drawBuffTower(x, y, size, color);
                    break;
                case 'repair':
                    drawRepairTower(x, y, size, color);
                    break;
                case 'shield':
                    drawShieldTower(x, y, size, color);
                    break;
                default:
                    draw3DCircle(x, y, size, color);
            }
        }
        
        // åŸºç¡€å¡” - ç®€å•çš„åœ†æŸ±å½¢
        function drawBasicTower(x, y, size, color) {
            // åŸºåº§
            draw3DCircle(x, y + size * 0.3, size * 1.1, darkenColor(color, 20));
            
            // ä¸»ä½“
            draw3DCircle(x, y, size, color);
            
            // ç‚®ç®¡
            ctx.fillStyle = darkenColor(color, 30);
            ctx.fillRect(x + size * 0.8, y - 2, size * 0.4, 4);
        }
        
        // å¿«é€Ÿå¡” - å¤šç®¡æœºæª
        function drawFastTower(x, y, size, color) {
            // åŸºåº§
            draw3DCircle(x, y + size * 0.2, size * 1.2, darkenColor(color, 15));
            
            // ä¸»ä½“
            draw3DCircle(x, y, size, color);
            
            // å¤šæ ¹ç‚®ç®¡
            ctx.fillStyle = darkenColor(color, 30);
            for(let i = 0; i < 3; i++) {
                const angle = (i * 15 - 15) * Math.PI / 180;
                const dx = Math.cos(angle);
                const dy = Math.sin(angle);
                ctx.fillRect(x + size * 0.7 * dx, y + size * 0.7 * dy - 1, size * 0.5, 2);
            }
        }
        
        // é‡å‹å¡” - å¤§ç‚®å¡”
        function drawHeavyTower(x, y, size, color) {
            // åŸºåº§
            draw3DRect(x - size * 1.2, y - size * 0.8, size * 2.4, size * 1.6, darkenColor(color, 20));
            
            // ç‚®å¡”
            draw3DCircle(x, y - size * 0.3, size * 0.8, color);
            
            // å¤§ç‚®ç®¡
            ctx.fillStyle = darkenColor(color, 25);
            ctx.fillRect(x + size * 0.8, y - size * 0.4, size * 0.8, size * 0.2);
            
            // ç‚®å£
            ctx.fillStyle = '#000000';
            ctx.beginPath();
            ctx.arc(x + size * 1.6, y - size * 0.3, size * 0.08, 0, Math.PI * 2);
            ctx.fill();
        }
        
        // ç‹™å‡»å¡” - é•¿ç®¡ç‹™å‡»é•œ
        function drawSniperTower(x, y, size, color) {
            // åŸºåº§
            draw3DCircle(x, y + size * 0.2, size * 1.1, darkenColor(color, 20));
            
            // ä¸»ä½“
            draw3DCircle(x, y, size * 0.9, color);
            
            // é•¿ç‹™å‡»ç®¡
            ctx.fillStyle = darkenColor(color, 30);
            ctx.fillRect(x + size * 0.7, y - 1, size * 1.2, 2);
            
            // ç„å‡†é•œ
            ctx.fillStyle = '#34495e';
            ctx.beginPath();
            ctx.arc(x + size * 0.3, y - size * 0.3, size * 0.15, 0, Math.PI * 2);
            ctx.fill();
            
            // é•œå¤´åå…‰
            ctx.fillStyle = 'rgba(255,255,255,0.6)';
            ctx.beginPath();
            ctx.arc(x + size * 0.25, y - size * 0.35, size * 0.05, 0, Math.PI * 2);
            ctx.fill();
        }
        
        // æœºæªå¡” - æ—‹è½¬æœºæª
        function drawMachineTower(x, y, size, color) {
            // åŸºåº§
            draw3DCircle(x, y + size * 0.2, size * 1.2, darkenColor(color, 15));
            
            // ä¸»ä½“
            draw3DCircle(x, y, size, color);
            
            // æ—‹è½¬æœºæª
            const rotation = Date.now() * 0.01;
            ctx.save();
            ctx.translate(x, y);
            ctx.rotate(rotation);
            
            ctx.fillStyle = darkenColor(color, 30);
            ctx.fillRect(size * 0.5, -2, size * 0.7, 4);
            ctx.fillRect(size * 0.5, -6, size * 0.7, 4);
            ctx.fillRect(size * 0.5, 2, size * 0.7, 4);
            
            ctx.restore();
        }
        
        // æ¿€å…‰å¡” - èƒ½é‡èšç„¦å™¨
        function drawLaserTower(x, y, size, color, energy) {
            // åŸºåº§
            draw3DCircle(x, y + size * 0.3, size * 1.1, darkenColor(color, 20));
            
            // ä¸»ä½“
            draw3DCircle(x, y, size, color);
            
            // èƒ½é‡æ ¸å¿ƒ
            const energyGlow = energy / 100;
            ctx.fillStyle = `rgba(231,76,60,${energyGlow})`;
            ctx.beginPath();
            ctx.arc(x, y, size * 0.4 * energyGlow, 0, Math.PI * 2);
            ctx.fill();
            
            // èšç„¦å™¨
            ctx.strokeStyle = lightenColor(color, 30);
            ctx.lineWidth = 2;
            for(let i = 0; i < 6; i++) {
                const angle = (i * 60) * Math.PI / 180;
                const dx = Math.cos(angle) * size * 0.8;
                const dy = Math.sin(angle) * size * 0.8;
                ctx.beginPath();
                ctx.moveTo(x + dx * 0.7, y + dy * 0.7);
                ctx.lineTo(x + dx, y + dy);
                ctx.stroke();
            }
        }
        
        // å†°å†»å¡” - å†°æ™¶ç»“æ„
        function drawFreezeTower(x, y, size, color) {
            // åŸºåº§
            draw3DCircle(x, y + size * 0.2, size * 1.1, darkenColor(color, 20));
            
            // ä¸»ä½“
            draw3DCircle(x, y, size, color);
            
            // å†°æ™¶
            ctx.strokeStyle = '#ffffff';
            ctx.lineWidth = 2;
            for(let i = 0; i < 6; i++) {
                const angle = (i * 60) * Math.PI / 180;
                const dx = Math.cos(angle) * size * 0.6;
                const dy = Math.sin(angle) * size * 0.6;
                ctx.beginPath();
                ctx.moveTo(x, y);
                ctx.lineTo(x + dx, y + dy);
                ctx.stroke();
            }
            
            // å†°é›¾æ•ˆæœ
            ctx.fillStyle = 'rgba(255,255,255,0.2)';
            ctx.beginPath();
            ctx.arc(x, y, size * 1.3, 0, Math.PI * 2);
            ctx.fill();
        }
        
        // æ¯’æ¶²å¡” - æ¯’æ¶²å®¹å™¨
        function drawPoisonTower(x, y, size, color) {
            // åŸºåº§
            draw3DCircle(x, y + size * 0.3, size * 1.1, darkenColor(color, 20));
            
            // ä¸»ä½“å®¹å™¨
            draw3DCircle(x, y, size, color);
            
            // æ¯’æ¶²
            ctx.fillStyle = '#16a085';
            ctx.beginPath();
            ctx.arc(x, y + size * 0.2, size * 0.7, 0, Math.PI * 2);
            ctx.fill();
            
            // æ¯’æ°”
            for(let i = 0; i < 3; i++) {
                ctx.fillStyle = `rgba(22,160,133,${0.3 - i * 0.1})`;
                ctx.beginPath();
                ctx.arc(x + Math.sin(Date.now() * 0.01 + i) * size * 0.3, 
                        y - size * (0.8 + i * 0.2), size * (0.2 + i * 0.1), 0, Math.PI * 2);
                ctx.fill();
            }
        }
        
        // ç‰¹æ–¯æ‹‰å¡” - ç”µèƒ½çº¿åœˆ
        function drawTeslaTower(x, y, size, color) {
            // åŸºåº§
            draw3DCircle(x, y + size * 0.3, size * 1.2, darkenColor(color, 20));
            
            // çº¿åœˆæ”¯æ¶
            ctx.strokeStyle = darkenColor(color, 30);
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.arc(x, y, size * 0.8, 0, Math.PI * 2);
            ctx.stroke();
            
            // ä¸­å¿ƒçƒ
            draw3DCircle(x, y, size * 0.4, color);
            
            // ç”µå¼§æ•ˆæœ
            const time = Date.now() * 0.02;
            ctx.strokeStyle = '#9b59b6';
            ctx.lineWidth = 2;
            for(let i = 0; i < 4; i++) {
                const angle = (time + i * 90) * Math.PI / 180;
                const startX = x + Math.cos(angle) * size * 0.4;
                const startY = y + Math.sin(angle) * size * 0.4;
                const endX = x + Math.cos(angle) * size * 0.8;
                const endY = y + Math.sin(angle) * size * 0.8;
                
                ctx.beginPath();
                ctx.moveTo(startX, startY);
                ctx.lineTo(endX + Math.sin(time * 3) * 3, endY + Math.cos(time * 3) * 3);
                ctx.stroke();
            }
        }
        
        // åŠ å†œç‚® - é‡å‹ç«ç‚®
        function drawCannonTower(x, y, size, color) {
            // åŸºåº§
            draw3DRect(x - size * 1.3, y - size, size * 2.6, size * 2, darkenColor(color, 25));
            
            // ç‚®åº§
            draw3DCircle(x, y - size * 0.2, size * 0.9, color);
            
            // ç‚®ç®¡
            ctx.fillStyle = darkenColor(color, 30);
            ctx.fillRect(x + size * 0.8, y - size * 0.35, size, size * 0.3);
            
            // ç‚®å£ç«ç„°æ•ˆæœ
            if (Math.random() < 0.1) {
                ctx.fillStyle = 'rgba(255,100,0,0.8)';
                ctx.beginPath();
                ctx.arc(x + size * 1.8, y - size * 0.2, size * 0.2, 0, Math.PI * 2);
                ctx.fill();
            }
        }
        
        // å¯¼å¼¹å¡” - å¯¼å¼¹å‘å°„å™¨
        function drawMissileTower(x, y, size, color) {
            // åŸºåº§
            draw3DCircle(x, y + size * 0.3, size * 1.2, darkenColor(color, 20));
            
            // å‘å°„æ¶
            draw3DRect(x - size * 0.8, y - size * 0.8, size * 1.6, size * 1.2, color);
            
            // å¯¼å¼¹
            for(let i = 0; i < 4; i++) {
                const missile_x = x - size * 0.6 + i * size * 0.4;
                const missile_y = y - size * 0.6;
                
                ctx.fillStyle = '#607d8b';
                ctx.fillRect(missile_x - size * 0.05, missile_y, size * 0.1, size * 0.5);
                
                // å¯¼å¼¹å¤´
                ctx.fillStyle = '#ff5722';
                ctx.beginPath();
                ctx.arc(missile_x, missile_y, size * 0.05, 0, Math.PI * 2);
                ctx.fill();
            }
        }
        
        // å¢ç›Šå¡” - å…‰ç¯æ•ˆæœ
        function drawBuffTower(x, y, size, color) {
            // åŸºåº§
            draw3DCircle(x, y + size * 0.2, size * 1.1, darkenColor(color, 20));
            
            // ä¸»ä½“
            draw3DCircle(x, y, size, color);
            
            // å¢ç›Šå…‰ç¯
            const time = Date.now() * 0.005;
            for(let i = 0; i < 3; i++) {
                ctx.strokeStyle = `rgba(241,196,15,${0.4 + Math.sin(time + i) * 0.2})`;
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.arc(x, y, size * (1.2 + i * 0.3), 0, Math.PI * 2);
                ctx.stroke();
            }
            
            // èƒ½é‡ç¬¦å·
            ctx.fillStyle = '#f1c40f';
            ctx.font = `${size}px Arial`;
            ctx.textAlign = 'center';
            ctx.fillText('+', x, y + size * 0.3);
            ctx.textAlign = 'left';
        }
        
        // ç»´ä¿®å¡” - åŒ»ç–—åå­—
        function drawRepairTower(x, y, size, color) {
            // åŸºåº§
            draw3DCircle(x, y + size * 0.2, size * 1.1, darkenColor(color, 20));
            
            // ä¸»ä½“
            draw3DCircle(x, y, size, color);
            
            // åŒ»ç–—åå­—
            ctx.fillStyle = '#ffffff';
            ctx.fillRect(x - size * 0.5, y - size * 0.15, size, size * 0.3);
            ctx.fillRect(x - size * 0.15, y - size * 0.5, size * 0.3, size);
            
            // æ²»ç–—å…‰æŸ
            ctx.strokeStyle = 'rgba(46,204,113,0.6)';
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.moveTo(x, y - size);
            ctx.lineTo(x, y - size * 2);
            ctx.stroke();
        }
        
        // æŠ¤ç›¾å¡” - èƒ½é‡æŠ¤ç›¾
        function drawShieldTower(x, y, size, color) {
            // åŸºåº§
            draw3DCircle(x, y + size * 0.3, size * 1.2, darkenColor(color, 20));
            
            // ä¸»ä½“
            draw3DCircle(x, y, size, color);
            
            // æŠ¤ç›¾ç”Ÿæˆå™¨
            ctx.strokeStyle = lightenColor(color, 30);
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.arc(x, y, size * 0.6, 0, Math.PI * 2);
            ctx.stroke();
            
            // æŠ¤ç›¾èƒ½é‡
            const time = Date.now() * 0.01;
            ctx.strokeStyle = `rgba(52,152,219,${0.5 + Math.sin(time) * 0.3})`;
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.arc(x, y, size * 1.5, 0, Math.PI * 2);
            ctx.stroke();
        }
        
        // äº‹ä»¶å¤„ç†
        document.getElementById('basicTower').onclick = () => selectTowerType('basic');
        document.getElementById('fastTower').onclick = () => selectTowerType('fast');
        document.getElementById('heavyTower').onclick = () => selectTowerType('heavy');
        document.getElementById('sniperTower').onclick = () => selectTowerType('sniper');
        document.getElementById('machineTower').onclick = () => selectTowerType('machine');
        document.getElementById('laserTower').onclick = () => selectTowerType('laser');
        document.getElementById('freezeTower').onclick = () => selectTowerType('freeze');
        document.getElementById('poisonTower').onclick = () => selectTowerType('poison');
        document.getElementById('teslaTower').onclick = () => selectTowerType('tesla');
        document.getElementById('cannonTower').onclick = () => selectTowerType('cannon');
        document.getElementById('missileTower').onclick = () => selectTowerType('missile');
        document.getElementById('pauseResume').onclick = togglePause;
        document.getElementById('upgradeTower').onclick = () => {
            if (gameState.gamePaused) {
                addNotification('æ¸¸æˆæš‚åœæ—¶æ— æ³•å‡çº§å¡”æ¥¼ï¼');
                return;
            }
            if (selectedTower) {
                selectedTower.upgrade();
                showTowerInfo(selectedTower);
            }
        };
        
        document.getElementById('demolishTower').onclick = () => {
            if (gameState.gamePaused) {
                addNotification('æ¸¸æˆæš‚åœæ—¶æ— æ³•æ‹†é™¤å¡”æ¥¼ï¼');
                return;
            }
            if (selectedTower) {
                demolishTower(selectedTower);
            }
        };
        
        // é¼ æ ‡ç§»åŠ¨äº‹ä»¶
        canvas.onmousemove = (e) => {
            try {
                const rect = canvas.getBoundingClientRect();
                // ä¿®æ­£åæ ‡è®¡ç®—ï¼Œè€ƒè™‘ç”»å¸ƒçš„å®é™…ç¼©æ”¾
                const scaleX = canvas.width / rect.width;
                const scaleY = canvas.height / rect.height;
                const x = (e.clientX - rect.left) * scaleX;
                const y = (e.clientY - rect.top) * scaleY;
                const gridPos = screenToGrid(x, y);
                
                
                gameState.hoveredCell = {
                    x: gridPos.x,
                    y: gridPos.y,
                    canPlace: (!gameState.gamePaused && gameState.selectedTowerType) ? canPlaceTower(gridPos.x, gridPos.y) : false
                };
            } catch (error) {
                console.error('Mouse move error:', error);
            }
        };
        
        canvas.onmouseleave = () => {
            gameState.hoveredCell = null;
        };
        
        function selectTowerType(type) {
            gameState.selectedTowerType = type;
            
            // æ›´æ–°æŒ‰é’®æ ·å¼
            document.querySelectorAll('.tower-btn').forEach(btn => btn.classList.remove('selected'));
            document.getElementById(type + 'Tower').classList.add('selected');
        }
        
        canvas.onclick = (e) => {
            const rect = canvas.getBoundingClientRect();
            // ä¿®æ­£åæ ‡è®¡ç®—ï¼Œè€ƒè™‘ç”»å¸ƒçš„å®é™…ç¼©æ”¾
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;
            const x = (e.clientX - rect.left) * scaleX;
            const y = (e.clientY - rect.top) * scaleY;
            const gridPos = screenToGrid(x, y);
            
            
            // æ£€æŸ¥æ˜¯å¦ç‚¹å‡»äº†å¡”æ¥¼
            selectedTower = null;
            for (let tower of gameState.towers) {
                if (tower.gridX === gridPos.x && tower.gridY === gridPos.y) {
                    selectedTower = tower;
                    showTowerInfo(tower);
                    return;
                }
            }
            
            // å¦‚æœæ²¡æœ‰ç‚¹å‡»å¡”æ¥¼ï¼Œéšè—å¡”æ¥¼ä¿¡æ¯
            hideTowerInfo();
            
            // æ£€æŸ¥æ˜¯å¦ç‚¹å‡»äº†èƒ½é‡é“å…·
            const clickX = (e.clientX - rect.left) * scaleX;
            const clickY = (e.clientY - rect.top) * scaleY;
            
            for (let powerUp of gameState.powerUps) {
                const distance = Math.sqrt((powerUp.x - clickX) ** 2 + (powerUp.y - clickY) ** 2);
                if (distance <= 20) { // 20åƒç´ çš„ç‚¹å‡»èŒƒå›´
                    if (!gameState.gamePaused) {
                        powerUp.collect();
                    } else {
                        addNotification('æ¸¸æˆæš‚åœæ—¶æ— æ³•æ”¶é›†é“å…·ï¼');
                    }
                    return; // æ”¶é›†åç›´æ¥è¿”å›ï¼Œä¸æ‰§è¡Œå…¶ä»–ç‚¹å‡»é€»è¾‘
                }
            }
            
            // æ”¾ç½®æ–°å¡”æ¥¼ï¼ˆæš‚åœæ—¶ä¸å…è®¸ï¼‰
            if (!gameState.gamePaused && gameState.selectedTowerType && canPlaceTower(gridPos.x, gridPos.y)) {
                const type = gameState.selectedTowerType;
                const cost = towerTypes[type].cost;
                
                if (gameState.money >= cost) {
                    const tower = new Tower(gridPos.x, gridPos.y, type);
                    gameState.towers.push(tower);
                    grid[gridPos.y][gridPos.x] = 1; // æ ‡è®°ä¸ºå¡”æ¥¼
                    gameState.money -= cost;
                    
                    // æ™ºèƒ½é‡æ–°è®¡ç®—æ•Œäººè·¯å¾„
                    recalculateEnemyPaths(gridPos.x, gridPos.y);
                    
                    addNotification(`å»ºé€ äº†${towerTypes[type].cost}é‡‘å¸çš„å¡”æ¥¼`);
                    playSound('towerBuild');
                    updateUI();
                } else {
                    addNotification('é‡‘å¸ä¸è¶³ï¼Œæ— æ³•å»ºé€ å¡”æ¥¼ï¼');
                }
            } else if (gameState.gamePaused && gameState.selectedTowerType) {
                addNotification('æ¸¸æˆæš‚åœæ—¶æ— æ³•å»ºé€ å¡”æ¥¼ï¼');
            }
        };
        
        function canPlaceTower(gridX, gridY) {
            // æ£€æŸ¥è¾¹ç•Œ
            if (gridX < 0 || gridX >= GRID_COLS || gridY < 0 || gridY >= GRID_ROWS) {
                return false;
            }
            
            // æ£€æŸ¥æ˜¯å¦å·²æœ‰å¡”æ¥¼æˆ–æ˜¯èµ·ç‚¹/ç»ˆç‚¹
            if (grid[gridY][gridX] !== 0) {
                return false;
            }
            
            // ä¸´æ—¶æ”¾ç½®å¡”æ¥¼ï¼Œæ£€æŸ¥æ˜¯å¦è¿˜æœ‰è·¯å¾„
            grid[gridY][gridX] = 1;
            const testPath = aStarPathfinding({x: 0, y: 1}, {x: GRID_COLS-1, y: GRID_ROWS-2}, grid);
            grid[gridY][gridX] = 0; // æ¢å¤
            
            return testPath.length > 0;
        }
        
        function getWaveComposition(wave) {
            const composition = [];
            const totalEnemies = Math.min(wave * 3 + 7, 35); // æœ€å¤š35ä¸ªæ•Œäºº
            
            // åŸºç¡€æ•Œäººæ¯”ä¾‹
            let basicCount = Math.max(1, Math.floor(totalEnemies * 0.3));
            let fastCount = wave > 2 ? Math.floor(totalEnemies * 0.15) : 0;
            let tankCount = wave > 4 ? Math.floor(totalEnemies * 0.12) : 0;
            let flyingCount = wave > 6 ? Math.floor(totalEnemies * 0.08) : 0;
            let heavyCount = wave > 8 ? Math.floor(totalEnemies * 0.08) : 0;
            let stealthCount = wave > 10 ? Math.floor(totalEnemies * 0.05) : 0;
            
            // æ–°æ•Œäººç±»å‹
            let berserkerCount = wave > 7 ? Math.floor(totalEnemies * 0.06) : 0;
            let healerCount = wave > 9 ? Math.floor(totalEnemies * 0.04) : 0;
            let splitterCount = wave > 11 ? Math.floor(totalEnemies * 0.05) : 0;
            let ghostCount = wave > 13 ? Math.floor(totalEnemies * 0.03) : 0;
            let shieldedCount = wave > 12 ? Math.floor(totalEnemies * 0.04) : 0;
            let swarmCount = wave > 6 ? Math.floor(totalEnemies * 0.1) : 0;
            let poisonCount = wave > 14 ? Math.floor(totalEnemies * 0.03) : 0;
            
            // BOSSç³»ç»Ÿ
            let bossCount = 0;
            let flyingBossCount = 0;
            let megaTankCount = 0;
            let airCarrierCount = 0;
            let ancientEvilCount = 0;
            
            if (wave % 5 === 0 && wave < 15) {
                bossCount = 1;
                basicCount = Math.floor(basicCount / 2);
            } else if (wave % 10 === 0 && wave < 20) {
                flyingBossCount = 1;
                basicCount = Math.floor(basicCount / 2);
            } else if (wave % 15 === 0 && wave < 30) {
                megaTankCount = 1;
                basicCount = Math.floor(basicCount / 3);
            } else if (wave % 20 === 0 && wave < 50) {
                airCarrierCount = 1;
                basicCount = Math.floor(basicCount / 3);
            } else if (wave % 25 === 0) {
                ancientEvilCount = 1;
                basicCount = Math.floor(basicCount / 4);
            }
            
            // æ„å»ºæ•Œäººåˆ—è¡¨
            for (let i = 0; i < basicCount; i++) composition.push('basic');
            for (let i = 0; i < fastCount; i++) composition.push('fast');
            for (let i = 0; i < tankCount; i++) composition.push('tank');
            for (let i = 0; i < flyingCount; i++) composition.push('flying');
            for (let i = 0; i < heavyCount; i++) composition.push('heavy');
            for (let i = 0; i < stealthCount; i++) composition.push('stealth');
            for (let i = 0; i < berserkerCount; i++) composition.push('berserker');
            for (let i = 0; i < healerCount; i++) composition.push('healer');
            for (let i = 0; i < splitterCount; i++) composition.push('splitter');
            for (let i = 0; i < ghostCount; i++) composition.push('ghost');
            for (let i = 0; i < shieldedCount; i++) composition.push('shielded');
            for (let i = 0; i < swarmCount; i++) composition.push('swarm');
            for (let i = 0; i < poisonCount; i++) composition.push('poison');
            
            // BOSS
            for (let i = 0; i < bossCount; i++) composition.push('boss');
            for (let i = 0; i < flyingBossCount; i++) composition.push('flyingBoss');
            for (let i = 0; i < megaTankCount; i++) composition.push('megaTank');
            for (let i = 0; i < airCarrierCount; i++) composition.push('airCarrier');
            for (let i = 0; i < ancientEvilCount; i++) composition.push('ancientEvil');
            
            // æ‰“ä¹±é¡ºåºï¼Œä½†BOSSæ”¾åœ¨æœ€å
            const bosses = composition.filter(type => enemyTypes[type].boss);
            const others = composition.filter(type => !enemyTypes[type].boss);
            
            // éšæœºæ‰“ä¹±éBOSSæ•Œäºº
            for (let i = others.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [others[i], others[j]] = [others[j], others[i]];
            }
            
            return [...others, ...bosses];
        }
        
        function demolishTower(tower) {
            // è®¡ç®—å›æ”¶èµ„é‡‘
            const refund = calculateRefund(tower);
            
            // å›æ”¶èµ„é‡‘
            gameState.money += refund;
            
            // ä»æ¸¸æˆä¸­ç§»é™¤å¡”æ¥¼
            const towerIndex = gameState.towers.indexOf(tower);
            if (towerIndex > -1) {
                gameState.towers.splice(towerIndex, 1);
            }
            
            // æ¸…é™¤ç½‘æ ¼æ ‡è®°
            grid[tower.gridY][tower.gridX] = 0;
            
            // é‡æ–°è®¡ç®—æ•Œäººè·¯å¾„ï¼ˆç§»é™¤å¡”æ¥¼å¯èƒ½ä¼šå¼€æ”¾æ–°è·¯å¾„ï¼‰
            recalculateEnemyPaths(tower.gridX, tower.gridY);
            
            // æ¸…é™¤é€‰ä¸­çŠ¶æ€
            selectedTower = null;
            hideTowerInfo();
            
            // é€šçŸ¥ç©å®¶
            addNotification(`æ‹†é™¤${tower.config.name}ï¼Œå›æ”¶${refund}é‡‘å¸`);
            playSound('towerBuild'); // ä½¿ç”¨å»ºé€ éŸ³æ•ˆ
            updateUI();
            
            // æ·»åŠ æ‹†é™¤ç²’å­æ•ˆæœ
            createDemolishEffect(tower.x, tower.y);
        }
        
        function createDemolishEffect(x, y) {
            // æ‹†é™¤ç²’å­æ•ˆæœ
            for(let i = 0; i < 20; i++) {
                gameState.particles.push(new Particle(x, y, 'explosion', {
                    vx: (Math.random() - 0.5) * 10,
                    vy: (Math.random() - 0.5) * 10,
                    color: '#95a5a6',
                    life: 50,
                    size: Math.random() * 5 + 2
                }));
            }
            
            // é‡‘å¸å›æ”¶æ•ˆæœ
            for(let i = 0; i < 8; i++) {
                const angle = (i / 8) * Math.PI * 2;
                gameState.particles.push(new Particle(x, y, 'sparkle', {
                    vx: Math.cos(angle) * 3,
                    vy: Math.sin(angle) * 3,
                    color: '#f1c40f',
                    life: 40,
                    size: 3
                }));
            }
        }
        
        function recalculateEnemyPaths(towerX, towerY) {
            // åªé‡æ–°è®¡ç®—å—å½±å“çš„æ•Œäººè·¯å¾„
            gameState.enemies.forEach(enemy => {
                // é£è¡Œæ•Œäººä¸å—åœ°é¢å¡”æ¥¼å½±å“
                if (enemy.config.flying) return;
                
                // æ£€æŸ¥æ•Œäººå½“å‰æ˜¯å¦åœ¨è¢«é˜»å¡çš„è·¯å¾„ä¸Šï¼Œæˆ–è€…å³å°†ç»è¿‡æ–°å¡”æ¥¼ä½ç½®
                let needsRecalculation = false;
                
                // æ£€æŸ¥å½“å‰è·¯å¾„æ˜¯å¦ä¼šç»è¿‡æ–°å¡”æ¥¼ä½ç½®
                if (enemy.path) {
                    for (let i = enemy.pathIndex; i < enemy.path.length; i++) {
                        const pathPoint = enemy.path[i];
                        if (pathPoint.x === towerX && pathPoint.y === towerY) {
                            needsRecalculation = true;
                            break;
                        }
                    }
                }
                
                // å¦‚æœéœ€è¦é‡æ–°è®¡ç®—ï¼Œåˆ™è°ƒç”¨findPath
                if (needsRecalculation) {
                    enemy.findPath();
                }
            });
        }
        
        function togglePause() {
            gameState.gamePaused = !gameState.gamePaused;
            const button = document.getElementById('pauseResume');
            
            if (gameState.gamePaused) {
                button.textContent = 'ç»§ç»­æ¸¸æˆ';
                addNotification('æ¸¸æˆå·²æš‚åœ');
            } else {
                button.textContent = 'æš‚åœæ¸¸æˆ';
                addNotification('æ¸¸æˆç»§ç»­');
            }
        }
        
        function startWave() {
            if (gameState.waveInProgress) return;
            
            gameState.waveInProgress = true;
            const waveComposition = getWaveComposition(gameState.wave);
            gameState.enemiesRemaining = waveComposition.length;
            gameState.enemiesSpawned = 0;
            gameState.currentWaveComposition = waveComposition;
            
            // æ˜¾ç¤ºæ³¢æ¬¡ä¿¡æ¯
            showWaveInfo(gameState.wave, waveComposition);
            updateWaveInfo(waveComposition);
            
            // ç”Ÿæˆæ•Œäºº
            const spawnInterval = setInterval(() => {
                if (gameState.enemiesSpawned >= gameState.enemiesRemaining || !gameState.gameRunning) {
                    clearInterval(spawnInterval);
                    return;
                }
                
                const enemyType = waveComposition[gameState.enemiesSpawned];
                gameState.enemies.push(new Enemy(enemyType, gameState.wave));
                gameState.enemiesSpawned++;
                updateUI();
            }, enemyTypes[waveComposition[gameState.enemiesSpawned]]?.boss ? 2000 : 800);
        }
        
        function showWaveInfo(wave, composition) {
            const enemyCount = {};
            composition.forEach(type => {
                enemyCount[type] = (enemyCount[type] || 0) + 1;
            });
            
            console.log(`ç¬¬${wave}æ³¢æ•Œäºº:`);
            Object.entries(enemyCount).forEach(([type, count]) => {
                console.log(`${enemyTypes[type].name}: ${count}`);
            });
        }
        
        function updateUI() {
            document.getElementById('health').textContent = gameState.health;
            document.getElementById('money').textContent = gameState.money;
            document.getElementById('wave').textContent = gameState.wave;
            document.getElementById('enemies').textContent = gameState.enemies.length;
            
            // æ˜¾ç¤ºæ¿€æ´»çš„èƒ½é‡é“å…·æ•ˆæœ
            const powerUpEffectsDiv = document.getElementById('powerUpEffects');
            let activeEffects = [];
            
            const now = Date.now();
            if (gameState.damageBoostActive && now < gameState.damageBoostEndTime) {
                const remaining = Math.ceil((gameState.damageBoostEndTime - now) / 1000);
                activeEffects.push(`ğŸ”¥ ä¼¤å®³æå‡ ${remaining}s`);
            }
            if (gameState.speedBoostActive && now < gameState.speedBoostEndTime) {
                const remaining = Math.ceil((gameState.speedBoostEndTime - now) / 1000);
                activeEffects.push(`âš¡ æ”»é€Ÿæå‡ ${remaining}s`);
            }
            if (gameState.freezeActive && now < gameState.freezeEndTime) {
                const remaining = Math.ceil((gameState.freezeEndTime - now) / 1000);
                activeEffects.push(`â„ï¸ æ—¶é—´å†»ç»“ ${remaining}s`);
            }
            if (gameState.timeWarpActive && now < gameState.timeWarpEndTime) {
                const remaining = Math.ceil((gameState.timeWarpEndTime - now) / 1000);
                activeEffects.push(`â° æ—¶é—´æ‰­æ›² ${remaining}s`);
            }
            if (gameState.goldRushActive && now < gameState.goldRushEndTime) {
                const remaining = Math.ceil((gameState.goldRushEndTime - now) / 1000);
                activeEffects.push(`ğŸ’° æ·˜é‡‘çƒ­ ${remaining}s`);
            }
            if (gameState.towerBoostActive && now < gameState.towerBoostEndTime) {
                const remaining = Math.ceil((gameState.towerBoostEndTime - now) / 1000);
                activeEffects.push(`ğŸ—ï¸ å¡”æ¥¼è¶…è½½ ${remaining}s`);
            }
            
            if (activeEffects.length > 0) {
                powerUpEffectsDiv.innerHTML = activeEffects.map(effect => 
                    `<div style="color: #f1c40f; margin: 2px 0; font-size: 10px;">${effect}</div>`
                ).join('');
                powerUpEffectsDiv.style.display = 'block';
            } else {
                powerUpEffectsDiv.style.display = 'none';
            }
        }
        
        function updateWaveInfo(composition) {
            const waveInfoDiv = document.getElementById('waveInfo');
            const compositionDiv = document.getElementById('waveComposition');
            
            if (composition && composition.length > 0) {
                const enemyCount = {};
                composition.forEach(type => {
                    enemyCount[type] = (enemyCount[type] || 0) + 1;
                });
                
                let html = '';
                Object.entries(enemyCount).forEach(([type, count]) => {
                    const config = enemyTypes[type];
                    const color = config.color;
                    const special = config.boss ? ' ğŸ‘‘' : (config.flying ? ' âœˆï¸' : (config.stealth ? ' ğŸ‘»' : ''));
                    html += `<div style="color: ${color}; margin: 1px 0; font-size: 10px;">${config.name}${special}: ${count}</div>`;
                });
                
                compositionDiv.innerHTML = html;
                waveInfoDiv.style.display = 'block';
            } else {
                waveInfoDiv.style.display = 'none';
            }
        }
        
        // é€šçŸ¥ç³»ç»Ÿ
        let notifications = [
            'ç‚¹å‡»é€‰æ‹©å¡”ç±»å‹ï¼Œç„¶ååœ¨ç½‘æ ¼ä¸­æ”¾ç½®',
            'ç‚¹å‡»æ”¶é›†æ‰è½çš„å½©è‰²èƒ½é‡é“å…·',
            'é£è¡Œæ•Œäººä¼šç›´çº¿é£è¡Œï¼Œæ— è§†å¡”æ¥¼',
            'æ¯5æ³¢å‡ºç°BOSSï¼Œæ¯10æ³¢å‡ºç°é£è¡ŒBOSS'
        ];
        
        function addNotification(message, type = 'info') {
            notifications.push(message);
            if (notifications.length > 5) {
                notifications.shift();
            }
            updateNotifications();
        }
        
        function updateNotifications() {
            const notificationsDiv = document.getElementById('notifications');
            let html = '';
            notifications.forEach(notification => {
                html += `<div class="notification">${notification}</div>`;
            });
            notificationsDiv.innerHTML = html;
        }
        
        function showTowerInfo(tower) {
            const infoDiv = document.getElementById('towerInfo');
            const nameDiv = document.getElementById('towerName');
            const descDiv = document.getElementById('towerDescription');
            const statsDiv = document.getElementById('towerStats');
            const upgradeBtn = document.getElementById('upgradeTower');
            const demolishBtn = document.getElementById('demolishTower');
            
            nameDiv.textContent = `${tower.config.name} (ç­‰çº§ ${tower.level})`;
            descDiv.textContent = tower.config.description;
            
            let stats = `ä¼¤å®³: ${tower.damage} | å°„ç¨‹: ${tower.range}`;
            if (tower.config.fireRate > 0) {
                stats += ` | æ”»é€Ÿ: ${(60000/tower.fireRate/16).toFixed(1)}/s`;
            }
            stats += ` | å‡»æ€: ${tower.kills}`;
            statsDiv.textContent = stats;
            
            // æ˜¾ç¤ºå‡çº§æŒ‰é’®
            if (tower.level < 3) {
                upgradeBtn.style.display = 'block';
                upgradeBtn.textContent = `å‡çº§ (${tower.getUpgradeCost()}é‡‘å¸)`;
            } else {
                upgradeBtn.style.display = 'none';
            }
            
            // æ˜¾ç¤ºæ‹†é™¤æŒ‰é’®å’Œå›æ”¶é‡‘é¢
            demolishBtn.style.display = 'block';
            const refundAmount = calculateRefund(tower);
            demolishBtn.textContent = `æ‹†é™¤ (å›æ”¶${refundAmount}é‡‘å¸)`;
            
            infoDiv.style.display = 'block';
        }
        
        function calculateRefund(tower) {
            // è®¡ç®—æ€»æŠ•èµ„æˆæœ¬
            let totalCost = tower.config.cost; // åŸºç¡€æˆæœ¬
            for (let i = 1; i < tower.level; i++) {
                totalCost += Math.floor(tower.config.cost * 0.6 * i); // å‡çº§æˆæœ¬
            }
            return Math.floor(totalCost * 0.8); // 80%å›æ”¶
        }
        
        function hideTowerInfo() {
            document.getElementById('towerInfo').style.display = 'none';
        }
        
        function endGame() {
            gameState.gameRunning = false;
            document.getElementById('finalWave').textContent = gameState.wave;
            document.getElementById('gameOver').style.display = 'block';
        }
        
        // å¤„ç†èƒ½é‡é“å…·æ•ˆæœ
        function handlePowerUpEffects() {
            const now = Date.now();
            
            // ä¼¤å®³æå‡æ•ˆæœ
            if (gameState.damageBoostActive && now > gameState.damageBoostEndTime) {
                gameState.damageBoostActive = false;
                addNotification("ä¼¤å®³æå‡æ•ˆæœç»“æŸ");
            }
            
            // æ”»é€Ÿæå‡æ•ˆæœ
            if (gameState.speedBoostActive && now > gameState.speedBoostEndTime) {
                gameState.speedBoostActive = false;
                addNotification("æ”»é€Ÿæå‡æ•ˆæœç»“æŸ");
            }
            
            // æ—¶é—´å†»ç»“æ•ˆæœ
            if (gameState.freezeActive) {
                if (now > gameState.freezeEndTime) {
                    gameState.freezeActive = false;
                    // æ¢å¤æ‰€æœ‰æ•Œäººçš„é€Ÿåº¦
                    gameState.enemies.forEach(enemy => {
                        enemy.speed = enemy.originalSpeed;
                    });
                    addNotification("æ—¶é—´å†»ç»“æ•ˆæœç»“æŸ");
                } else {
                    // å†»ç»“æ‰€æœ‰æ•Œäºº
                    gameState.enemies.forEach(enemy => {
                        // æ•Œäººé€Ÿåº¦å‡ä¸º0
                        enemy.speed = 0;
                    });
                }
            } else {
                // ç¡®ä¿å†»ç»“æ•ˆæœç»“æŸåæ•Œäººé€Ÿåº¦æ¢å¤æ­£å¸¸
                gameState.enemies.forEach(enemy => {
                    if (enemy.speed === 0 && enemy.originalSpeed > 0) {
                        enemy.speed = enemy.originalSpeed;
                    }
                });
            }
            
            // æ—¶é—´æ‰­æ›²æ•ˆæœç»“æŸ
            if (gameState.timeWarpActive && now > gameState.timeWarpEndTime) {
                gameState.timeWarpActive = false;
                // æ¢å¤æ•Œäººé€Ÿåº¦
                gameState.enemies.forEach(enemy => {
                    if (enemy.originalSpeed) {
                        enemy.speed = enemy.originalSpeed;
                    }
                });
                addNotification("æ—¶é—´æ‰­æ›²æ•ˆæœç»“æŸ");
            }
            
            // æ·˜é‡‘çƒ­æ•ˆæœç»“æŸ
            if (gameState.goldRushActive && now > gameState.goldRushEndTime) {
                gameState.goldRushActive = false;
                addNotification("æ·˜é‡‘çƒ­æ•ˆæœç»“æŸ");
            }
            
            // å¡”æ¥¼è¶…è½½æ•ˆæœç»“æŸ
            if (gameState.towerBoostActive && now > gameState.towerBoostEndTime) {
                gameState.towerBoostActive = false;
                addNotification("å¡”æ¥¼è¶…è½½æ•ˆæœç»“æŸ");
            }
        }
        
        // æ¸¸æˆå¾ªç¯
        function gameLoop() {
            if (!gameState.gameRunning) return;
            
            // æ¸…ç©ºç”»å¸ƒ
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // ç”»ç½‘æ ¼
            ctx.strokeStyle = 'rgba(255,255,255,0.3)';
            ctx.lineWidth = 1;
            // ç¡®ä¿ç½‘æ ¼çº¿åœ¨åƒç´ è¾¹ç•Œä¸Šï¼Œé¿å…æ¨¡ç³Š
            for (let x = 0; x <= canvas.width; x += GRID_SIZE) {
                const pixelX = Math.floor(x) + 0.5;
                ctx.beginPath();
                ctx.moveTo(pixelX, 0);
                ctx.lineTo(pixelX, canvas.height);
                ctx.stroke();
            }
            for (let y = 0; y <= canvas.height; y += GRID_SIZE) {
                const pixelY = Math.floor(y) + 0.5;
                ctx.beginPath();
                ctx.moveTo(0, pixelY);
                ctx.lineTo(canvas.width, pixelY);
                ctx.stroke();
            }
            
            // ç»˜åˆ¶ç½‘æ ¼èƒŒæ™¯
            for (let y = 0; y < GRID_ROWS; y++) {
                for (let x = 0; x < GRID_COLS; x++) {
                    const screenPos = gridToScreen(x, y);
                    
                    // èµ·ç‚¹å’Œç»ˆç‚¹
                    if (grid[y][x] === 2) {
                        ctx.fillStyle = 'rgba(46, 204, 113, 0.3)';
                        ctx.fillRect(x * GRID_SIZE, y * GRID_SIZE, GRID_SIZE, GRID_SIZE);
                    } else if (grid[y][x] === 3) {
                        ctx.fillStyle = 'rgba(231, 76, 60, 0.3)';
                        ctx.fillRect(x * GRID_SIZE, y * GRID_SIZE, GRID_SIZE, GRID_SIZE);
                    }
                }
            }
            
            // é¼ æ ‡æ‚¬åœæ•ˆæœ
            if (gameState.hoveredCell) {
                const x = gameState.hoveredCell.x * GRID_SIZE;
                const y = gameState.hoveredCell.y * GRID_SIZE;
                
                if (gameState.gamePaused) {
                    // æš‚åœæ—¶æ˜¾ç¤ºçº¢è‰²ç¦ç”¨æç¤º
                    ctx.fillStyle = 'rgba(231, 76, 60, 0.6)';
                } else if (!gameState.selectedTowerType) {
                    // æ²¡æœ‰é€‰æ‹©å¡”æ¥¼ç±»å‹æ—¶æ˜¾ç¤ºç°è‰²æç¤º
                    ctx.fillStyle = 'rgba(149, 165, 166, 0.3)';
                } else if (gameState.hoveredCell.canPlace) {
                    // å¯ä»¥æ”¾ç½®æ—¶æ˜¾ç¤ºè“è‰²
                    ctx.fillStyle = 'rgba(52, 152, 219, 0.4)';
                } else {
                    // ä¸èƒ½æ”¾ç½®æ—¶æ˜¾ç¤ºçº¢è‰²
                    ctx.fillStyle = 'rgba(231, 76, 60, 0.4)';
                }
                ctx.fillRect(x, y, GRID_SIZE, GRID_SIZE);
                
                // æ˜¾ç¤ºç½‘æ ¼åæ ‡ï¼ˆè°ƒè¯•ç”¨ï¼‰
                ctx.fillStyle = 'white';
                ctx.font = '10px Arial';
                ctx.textAlign = 'center';
                ctx.fillText(`${gameState.hoveredCell.x},${gameState.hoveredCell.y}`, x + GRID_SIZE/2, y + GRID_SIZE/2);
                ctx.textAlign = 'left';
            }
            
            // ç”»èµ·ç‚¹å’Œç»ˆç‚¹æ ‡ç­¾
            ctx.fillStyle = '#2ecc71';
            ctx.font = '12px Arial';
            ctx.fillText('èµ·ç‚¹', 5, 20);
            
            ctx.fillStyle = '#e74c3c';
            ctx.fillText('ç»ˆç‚¹', canvas.width - 40, canvas.height - 10);
            
            // æ›´æ–°å’Œç»˜åˆ¶æ¸¸æˆå¯¹è±¡
            if (!gameState.gamePaused) {
                gameState.towers.forEach(tower => {
                    tower.update();
                });
                
                // å¤„ç†èƒ½é‡é“å…·æ•ˆæœ
                handlePowerUpEffects();
                
                gameState.enemies.forEach(enemy => {
                    enemy.update();
                });
                
                gameState.projectiles.forEach(projectile => {
                    projectile.update();
                });
                
                gameState.particles.forEach(particle => {
                    particle.update();
                });
                
                gameState.powerUps.forEach(powerUp => {
                    powerUp.update();
                });
            }
            
            // ç»˜åˆ¶æ‰€æœ‰å¯¹è±¡ï¼ˆå³ä½¿æš‚åœä¹Ÿè¦ç»˜åˆ¶ï¼‰
            gameState.towers.forEach(tower => {
                tower.draw();
            });
            
            gameState.enemies.forEach(enemy => {
                enemy.draw();
            });
            
            gameState.projectiles.forEach(projectile => {
                projectile.draw();
            });
            
            gameState.particles.forEach(particle => {
                particle.draw();
            });
            
            gameState.powerUps.forEach(powerUp => {
                powerUp.draw();
            });
            
            // æ˜¾ç¤ºæš‚åœçŠ¶æ€
            if (gameState.gamePaused) {
                ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                ctx.fillStyle = '#ffffff';
                ctx.font = 'bold 48px Arial';
                ctx.textAlign = 'center';
                ctx.strokeStyle = '#000000';
                ctx.lineWidth = 3;
                ctx.strokeText('æ¸¸æˆæš‚åœ', canvas.width / 2, canvas.height / 2 - 40);
                ctx.fillText('æ¸¸æˆæš‚åœ', canvas.width / 2, canvas.height / 2 - 40);
                
                ctx.font = '18px Arial';
                ctx.strokeText('ç‚¹å‡»"ç»§ç»­æ¸¸æˆ"æŒ‰é’®æ¢å¤', canvas.width / 2, canvas.height / 2 + 10);
                ctx.fillText('ç‚¹å‡»"ç»§ç»­æ¸¸æˆ"æŒ‰é’®æ¢å¤', canvas.width / 2, canvas.height / 2 + 10);
                
                ctx.font = '14px Arial';
                ctx.fillStyle = '#ffcc00';
                ctx.strokeText('æš‚åœæœŸé—´æ— æ³•å»ºé€ ã€å‡çº§å¡”æ¥¼', canvas.width / 2, canvas.height / 2 + 40);
                ctx.fillText('æš‚åœæœŸé—´æ— æ³•å»ºé€ ã€å‡çº§å¡”æ¥¼', canvas.width / 2, canvas.height / 2 + 40);
                ctx.textAlign = 'left';
            }
            
            // æ£€æŸ¥æ³¢æ¬¡æ˜¯å¦å®Œæˆå’Œè‡ªåŠ¨å¼€å§‹ä¸‹ä¸€æ³¢
            if (!gameState.gamePaused) {
                if (gameState.waveInProgress && gameState.enemies.length === 0 && gameState.enemiesSpawned >= gameState.enemiesRemaining) {
                    gameState.waveInProgress = false;
                    const reward = 20 + (gameState.wave * 5);
                    gameState.money += reward;
                    addNotification(`ç¬¬${gameState.wave}æ³¢å®Œæˆï¼è·å¾—${reward}é‡‘å¸å¥–åŠ±`);
                    gameState.wave++;
                    updateWaveInfo(null); // æ¸…é™¤æ³¢æ¬¡ä¿¡æ¯
                    updateUI();
                    
                    // è®¾ç½®ä¸‹ä¸€æ³¢å¼€å§‹æ—¶é—´
                    if (gameState.autoWave) {
                        gameState.nextWaveTime = Date.now() + gameState.waveStartDelay;
                        addNotification(`${Math.floor(gameState.waveStartDelay/1000)}ç§’åè‡ªåŠ¨å¼€å§‹ç¬¬${gameState.wave}æ³¢`);
                    }
                }
                
                // è‡ªåŠ¨å¼€å§‹ä¸‹ä¸€æ³¢
                if (gameState.autoWave && !gameState.waveInProgress && gameState.nextWaveTime > 0 && Date.now() >= gameState.nextWaveTime) {
                    gameState.nextWaveTime = 0;
                    startWave();
                }
            }
            
            requestAnimationFrame(gameLoop);
        }
        
        // åˆå§‹åŒ–æ¸¸æˆ
        updateUI();
        updateNotifications();
        
        // å»¶è¿Ÿ2ç§’åè‡ªåŠ¨å¼€å§‹ç¬¬ä¸€æ³¢
        setTimeout(() => {
            if (gameState.gameRunning && !gameState.waveInProgress) {
                startWave();
            }
        }, 2000);
        
        gameLoop();
    </script>
</body>
</html>
